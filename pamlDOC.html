<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title> PAML Manual (Phylogenetic Analysis by Maximum Likelihood) </title>
</head>

<body>

<h1 align="center"><font face="Garamond">PAML Manual<br>
(Phylogenetic Analysis by Maximum Likelihood)</font></h1>

<p align="center"><font color="#FF0000" size="4">Version 2.0k,
March 2000 </font></p>

<p align="center">Ziheng Yang </p>

<p align="center">© Copyright 1994, 1995, 1996, 1997, 1998,
1999, 2000 by Ziheng Yang. The software package is provided
&quot;as is&quot; without warranty of any kind. In no event shall
the author be held responsible for any damage resulting from the
use of this software, including but not limited to the
frustration that you may experience in using the package. The
program package, including source codes, example data sets,
executables, and this documentation, is distributed free of
charge for academic use only. </p>

<p align="center">Suggested citation: </p>

<p align="center">Yang, Z. 1997. PAML: a program package for
phylogenetic analysis by maximum likelihood. CABIOS <b>13</b>:555-556.
<br>
or <br>
Yang, Z. 2000. Phylogenetic Analysis by Maximum Likelihood
(PAML), Version 2.0. University College London.</p>

<p align="center">The author can be reached at <br>
<a href="http://abacus.gene.ucl.ac.uk/ziheng/ziheng.html">Ziheng
Yang</a><br>
<a href="http://www.ucl.ac.uk/biology/">Department of Biology </a><br>
<a href="http://www.gene.ucl.ac.uk/">Galton Laboratory </a><br>
<a href="http://www.ucl.ac.uk/">University College London </a><br>
<a href="http:../how2findus.html">4 Stephenson Way</a><br>
London NW1 2HE <br>
Email: <a href="mailto:z.yang@ucl.ac.uk">z.yang@ucl.ac.uk</a> <br>
Phone: +44 (171) 504 5083 <br>
Fax: +44 (171) 383 2048</p>

<hr>

<h1><a name="toc">Table of contents</a></h1>

<ul>
    <li><a href="#changes">Recent changes </a></li>
    <li><a href="#introduction">Introduction </a></li>
    <li><a href="#files">Files in the package </a></li>
    <li><a href="#running">Running the Programs </a><ul>
            <li><a href="#initials">Initial values </a></li>
            <li><a href="#finetuning">Finetuning the iteration
                algorithm </a></li>
            <li><a href="#basemlg">Running <code>basemlg</code> </a></li>
            <li><a href="#macmemory">MAC memory allocation </a></li>
            <li><a href="#winwindow">Windows version window
                auto-close </a></li>
        </ul>
    </li>
    <li><a href="#input">Input File Formats </a><ul>
            <li><a href="#sequences">Sequence data format </a></li>
            <li><a href="#trees">Tree structure file and
                representations of the tree topologies</a> </li>
            <li><a href="#baseml.ctl">The control file for
                programs <code>baseml</code> and <code>basemlg</code></a>
            </li>
            <li><a href="#codeml.ctl">The control file for the
                program <code>codeml</code> (<code>codonml</code>
                and <code>aaml</code>) </a></li>
            <li><a href="#mcmctree.ctl">The control file for the
                program <code>mcmctree</code> </a></li>
        </ul>
    </li>
    <li><a href="#interpreting">Interpreting Outputs </a><ul>
            <li><a href="#mlb">Output file for <code>baseml</code></a>
            </li>
            <li><a href="#mlc">Output file for <code>codeml</code>
                (<code>codonml</code> and <code>aaml</code>) </a></li>
            <li><a href="#rst">Secondary result files <code>rst</code>
                and <code>rates</code> </a></li>
        </ul>
    </li>
    <li><a href="#models">Models and Methods </a><ul>
            <li><a href="#Q4">Substitution models for nucleotides
                (<code>baseml</code>) </a></li>
            <li><a href="#Qcodon">Substitution models for codons
                (<code>codonml:</code> <code>codeml.c</code> with
                <code>seqtype</code>=1) </a></li>
            <li><a href="#Q20">Substitution models for amino
                acids (<code>aaml: codeml.c</code> with <code>seqtype=2</code>)
                </a></li>
            <li><a href="#rates">Variable substitution rates
                across sites </a></li>
            <li><a href="#mgene">Models for combined analyses of
                heterogeneous data (multiple genes or codon
                positions)</a> </li>
            <li><a href="#clock">The molecular clock </a></li>
            <li><a href="#nhomo">The nonhomogeneous models (<code>nhomo</code>
                for <code>baseml</code>)</a> </li>
            <li><a href="#ancestral">Reconstruction of ancestral
                sequences </a></li>
            <li><a href="#bayes">Bayesian estimation of
                phylogenetic trees </a></li>
            <li><a href="#simulate">Simulating sequence data sets
                </a></li>
            <li><a href="#treesearch">Tree search algorithms </a></li>
        </ul>
    </li>
    <li><a href="#technical">Technical details, problems and
        limitations </a><ul>
            <li><a href="#variables">Adjustable variables in the
                source codes </a></li>
            <li><a href="#problems">Known problems </a></li>
        </ul>
    </li>
</ul>

<ul>
    <li><a href="#thanks">Acknowledgments</a> </li>
    <li><a href="#references">References </a></li>
</ul>

<hr>

<h1><a href="#toc">Recent changes</a></h1>

<p><b>Changes from version 2.0j to 2.0k (March 14, 2000):</b></p>

<p>1. I have added the program <font face="Courier New">yn00</font>,
which implements the method of Yang and Nielsen (2000) for
estimating synonymous and nonsynonymous substitution rates
between two sequences (dS and dN). This paragraph will serve as
the manual for the program, until I update this documen later.
The control file <font face="Courier New">yn00.ctl</font>
specifies the sequence data file name, output file name, and the
genetic code (icode). The variable <font face="Courier New">weighting</font>
decides whether equal weighting or unequal weighting will be used
when counting differences between codons. The two approaches will
be different for divergent sequences, and unequal weighting is
much slower computationally. The transition/transversion rate
ratio kappa is estimated for all sequences in the data file and
used in subsequent pairwise comparisons. I hope to add an option
to allow kappa to be estimated for each pair. commonf3x4
specifies whether codon frequencies (based on the F3x4 model of
codonml) should be estimated for each pair or for all sequences
in the data. Besides the main result file, the program also
generates three distance matrices: 2YN.dS for synonymous rates,
2YN.dN for nonsynonymous rates, 2YN.t for the combined codon rate
(t is measured as the number of nucleotide substitutions per
codon). It should be possible to use those files directly with
distance programs such as NEIGHBOR in Felesenstein's PHYLIP.
Codon sites involving alignment gaps or ambiguity nucleotides in
any sequence are removed from all sequences.</p>

<p>The ad hoc method implemented in the program accounts for the
transition/transversion rate bias and codon usage bias, and is an
approximation to the ML method accounting for the
transition/transversion rate ratio and assuming the F3x4 codon
frequency model. The authors of the method recommend that you use
the ML method (runmode=2, Fcodon = 2 in codeml.ctl) as much as
possible even for pairwise sequence comparison. This program is
not well tested as I am in a hurry to prepare a release. It also
seems slower than I expect. I plan to make some improvements
later on. Please let me know of any problems.</p>

<p>2. <font face="Courier New">codeml</font>. I added some notes
in the output to identify parameters in the NSsites models. I
also compiled an executable file <font face="Courier New">codemlsites</font>
which runs the NSsites models in a batch mode. The new models
(NSsites = 3, 7, and 8) are sometimes more powerful than the old
selection model (NSsites = 2), and so you should try them if the
selection model fails to detect positive selection. We are
compiling examples of positive selection, and will appreciate a
copy of your manuscript that identifies sites under selection
using those models. The new models are described in a paper for
Genetics by Yang, Nielsen, Goldman, &amp; Pedersen. The files are
: </p>

<blockquote>
    <p>ftp://abacus.gene.ucl.ac.uk/pub/YNGP2000/Yang.doc (MS Word
    97 doc)<br>
    ftp://abacus.gene.ucl.ac.uk/pub/YNGP2000/YangTab.doc (tables)<br>
    ftp://abacus.gene.ucl.ac.uk/pub/YNGP2000/fig1.ps<br>
    ftp://abacus.gene.ucl.ac.uk/pub/YNGP2000/fig2.ps<br>
    </p>
</blockquote>

<p><b>Changes from version 2.0i to 2.0j (Feb 16, 2000):</b></p>

<p>The program evolver used the Taylow expansion to calculate
transition probability matrices and may not generate sequences
correctly if branch lengths are very large, say &gt;10 changes
per site. This is now fixed, by using the matrix algebra. </p>

<p>Scaling by nodes to avoid underflow. When there are many
sequences in the data (say &gt; 200 or 300), the probability of
observing data at a site can become too small to represent in the
machine. This is because the probabilities are multiplied along
branches in the tree and a large tree has many branches. Since
version 2.0, this underflow is dealt with by scaling, and it
works with both the one-rate and gamma-rates models. It did not
work with the NSsites models in codonml, but probably nobody has
analysed large data sets to notice this. Anyway, this version
hopefully fixes that problem. If you use the program on very
large data sets, watch out for anything strange and let me know.
I suppose with the option of using supplied branch lengths, data
sets of such sizes will become manageable, and this scaling will
become important. </p>

<p><b>Changes from version 2.0g to 2.0h (Oct 14, 1999):</b></p>

<p>If the tree file has more than one tree, the programs baseml
and codeml will calculate the bootstrap proportions using the
RELL method (Kishino and Hasegawa 1989). This calculation also
takes into account possible data partitions in the bootstrap
sampling, and so will work with the G option in the sequence data
file as well. The programs do not account for ties, so if you
include the same tree in the tree file more than once, you need
to adjust the proportions for those trees yourself. The program
rell, which was included in earlier versions, is now removed from
the package.</p>

<p>The RemoveIndel routine in 2.0e and 20.f has a bug that
removes most sites in the sequence except those with all T's and
C's for baseml. The same routine in 2.0g has a different bug that
removes most sites except those will all T's and C's in the
sequence for aaml. In either case, the results will be grossly
wrong. The bugs affect the analysis only if you have gaps or
ambiguity characters in the data and use runmode = 1 for aaml in
2.0e and 2.0f, and runmode = 1 for codonml for 2.0g. </p>

<p>The newly introduced option for amino acid reconstruction by
baseml (icode) does not work. The program aborts with an error
message. This is now fixed. </p>

<p><b>Changes from version 2.0f to 2.0g (Sept 21, 1999):</b></p>

<p>2.0f implemented the option of fixing branch lengths rather
than estimating them by iteration. When the tree has branch
lengths, the programs use those branch lengths as fixed and
estimate other parameters in the substitution model only. This
may not be what the user intends to do. In 2.0g, the program will
ask a question. The options are 0: ignore the branch lengths, 1:
use them as initial values, and 2: fix them and estimate other
parameters. This question is asked for the first tree only, and
the answer will be used for later trees as well. If you run the
program on a UNIX machine, you should run it on the foreground,
and answer the question before putting it on the background (by
Ctrl-Z and then bg). </p>

<p>For those who have used model = 2 in codonml to fit models of
variable dN/dS ratios among lineages on large phylogenies, 2.0g
allows the user to specify node (branch) labels. A label for a
branch is also a label for the descendent node of that branch.
The label is a small integer preceeded by the symbols # or $. The
default label for each node (branch) is 0 so that you do not have
to specify it. Other labels should use consecutive numbers larger
than 0. For example, the following tree</p>

<p><code>((Hsa_Human, Hla_gibbon) #1, ((Cgu/Can_colobus,
Pne_langur), Mmu_rhesus), (Ssc_squirrelM, Cja_marmoset)); </code></p>

<p>means that the internal branch ancestral to human and gibbon
has the ratio w1 while all other branches have the background
ratio w0. This fits the model in table 1C for the small data set
of lysozyme genes in Yang (1998). The branch (node) labels will
also be useful for other models that allow certain parameters
(such as the substitution rate, transition/transversion rate
ratio, and base frequency parameters) to vary from branch to
branch. I have found it convenienet to create the tree file with
labels and read the tree in using <a
href="http://taxonomy.zoology.gla.ac.uk/rod/rod.html">TreeView</a>
to check that the tree is right. TreeView right now only reads
labels but do not allow the user to add labels. Hopefully Rod
Page will add this option soon, and then it can generate files
that are directly usable in paml. I have found this option easy
to use than the other option (which is still available) which
asks the user to specify the branch marks.</p>

<p><b>Changes from version 1.4 to 2.0</b></p>

<p>After version 1.4, I posted two temporary versions, which
involved a major change to handle missing data (ambiguity
characters and alignment gaps) in the likelihood calculation.
Some analyses were disabled in the temporary versions, including
ancestral reconstruction and parsimony-based analysis (<code>pamp</code>).
These are believed to be fixed, and all programs in the package
should now work. The following are changes/updates relative to
version 1.4. </p>

<ol>
    <li>No changes: Regrettably, there has been no improvement in
        heuristic tree search, and no major improvement in the
        numerical optimization algorithms. </li>
    <li>Missing data: baseml and codeml now handle missing data.
        The idea used here is due to Joe Felsenstein; thanks to
        him for insisting on its correctness. Choose <code>cleandata
        = 1</code> in the control file to remove sites with
        ambiguity characters or alignment gaps, as did previous
        versions. The programs are slower if missing data are
        included in the analysis than if they are removed (option
        variable <code>cleandata = 1</code>) or absent. </li>
    <li>Clock: The molecular clock option (clock = 1) is now
        fixed by reparametrizing the model. Thanks to Jeff Thorne
        for his idea. </li>
    <li>Nexus file formats: PAML programs now have limited
        support for sequence file format used by PAUP and
        MacClade. Only the sequence data or tree are read, and
        command blocks are all ignored. </li>
    <li>Ancestral reconstruction of nucleotide, codon, and amino
        acid sequences: &quot;Marginal&quot; ancestral
        reconstructions are now done under the model of
        gamma-rates for sites as well as the constant-rate model.
        For protein-coding genes, reconstructions can now be done
        at the nucleotide level with <code>baseml</code> (in
        particular, by using models that account for differences
        at the three codon positions; Yang 1996a), at the amino
        acid level with <code>aaml</code>, and at the codon level
        with <code>codonml</code>. Results for ancestral
        reconstruction are now listed by site. Missing data are
        now handled in the marginal recosntruction. See
        instructions in this document about the control files for
        more options. Thanks to Belinda Chang for a lot of
        suggestions. </li>
    <li>Distance matrices from codonml and aaml. The program
        codonml outputs matrices of synonymous and nonsynonymous
        rates in all pairwise comparisons using the method of Nei
        and Gojobori (1986) into two files named <code>DistanceNG.dN</code>
        and <code>DistanceNG.dN</code>. The matrices are
        lower-diagonal and can be used with programs (such as
        neighbor and fitch) in phylip (and possibly paup* too)
        for tree reconstruction or branch length estimation by
        distance methods. If you choose runmode = -2 for ML
        pairwise comparison, the program will also output two
        matrices of ML estimates of dS and dN into the files <code>DistanceML.dS</code>
        and <code>DistanceML.dN</code>. Since many users seem
        interested in looking at dN/dS rate ratios among
        lineages, examination of the tree shapes indicated by
        branch lengths calculated from the two rates may be
        interesting although the analysis is ad hoc. Sites
        involving ambuiguity data are removed from this pairwise
        ML comparison. Obviously, you should NOT name your own
        data files with those names; otherwise they will get
        overwritten. If your species name has no more than 10
        characters, you should be able to use the output distance
        matrices as input to Phylip programs without any change.
        Otherwise you need to edit the files to cut the names
        short. For amino acid sequences (<code>aaml</code>), the
        same option (<code>runmode = -2</code>) forces the
        program to calculate pairwise distances by maximum
        likelihood. To choose the right model, you can change the
        following variables in the control file <code>codeml.ctl</code>:
        <code>runmode, aaRatefile, model, and alpha</code>.
        Thanks to David Posada. </li>
    <li>Codon substitution models for testing adpative evolution.
        I fixed a minor prompt error in version 1.4 (model = 2 in
        codonml) for models of variable dN/dS ratios among
        lineages (Yang 1998; Yang and Nielsen 1998). The example
        data set <code>lysozymeSmall.nuc</code> is included for
        the user to duplicate results in Yang (1998 Molecular
        Biology and Evolution 15: 568-573). Besides this
        documentation, the control file <code>lysozyme.ctl</code>
        explains in detail how to specify the options. I would
        like to remind you that it is not exactly correct to use
        the option model = 1 to estimate dN/dS ratios for all
        branches to find out which ratios are greater than one,
        and then to use model = 2 to test whether that difference
        is significant. The problem with this is that the
        hypothesis being tested will be derived from the data
        which you use to test the hypothesis, and as a result,
        you tend to get significant results too often. Correctly,
        the hypothesis should be formulated before the data are
        analyzed. The example data set for models of variable
        dN/dS ratios among sites (Nielsen and Yang 1998) is <code>HIVenvY7.unc</code>.
        This is the year 7 data, and the trees are at the end of
        the data file. </li>
    <li>Simulating nucleotide, codon, and amino acid sequences.
        The program <code>evolver</code> (it used to be named <code>listtree</code>)
        now has options for simulating sequence data sets based
        on nucleotide, codon, and amino acid substitution models,
        besides its old options for generating random trees. </li>
</ol>

<h1><a href="#toc">Introduction</a></h1>

<p>PAML is a package of programs for phylogenetic analyses of DNA
or protein sequences using maximum likelihood (ML). The PAML web
page explains what the programs can and cannot do, how to
download and compile the programs, and how to report bugs. Those
sections will not be duplicated in this documentation. </p>

<p>The program <code>baseml</code> is for analyzing nucleotide
sequences. The program <code>codeml</code> is formed by merging
two old programs: <code>codonml</code>, which implements the
codon substitution model of Goldman and Yang (1994) for
protein-coding DNA sequences, and <code>aaml</code>, which
implements models for amino acid sequences. These two are now
distinguished by a variable named <code>seqtype</code> in <code>codeml</code>,
which is 1 for codon sequences and 2 for amino acid sequences. In
this document I use <code>codonml</code> and <code>aaml</code> to
mean <code>codeml</code> with <code>seqtype</code> = 1 and 2,
respectively. The programs <code>baseml</code>, <code>codonml</code>,
and <code>aaml</code> use similar algorithms to fit models, the
difference being that the unit of evolution in the substitution
model, referred to as a &quot;site&quot; in the sequence, is a
nucleotide, a codon, or an amino acid for the three programs,
respectively. Markov process models are used to describe
substitutions between nucleotides, codons or amino acids, with
substitution rates assumed to be either constant or variable
among sites. A <i>discrete-gamma</i> model (Yang, 1994c) is used
in <code>baseml</code>, <code>codonml</code> and <code>aaml</code>
to accommodate rate variation among sites, by which rates for
sites come from several (say, four or eight) categories used to
approximate the continuous gamma distribution. When rates are
variable at sites, a correlation of rates between adjacent sites
can be accounted for using an <i>auto-discrete-gamma </i>model
(Yang, 1995). </p>

<p>The program <code>basemlg</code> implements the continuous
gamma model of Yang (1993). It is slow and feasible for data of
4-6 species only. The discrete-gamma model in <code>baseml</code>
is recommended.</p>

<p>General assumptions of the models (programs): </p>

<ul>
    <li>Substitutions occur independently in different lineages; </li>
    <li>Substitutions occur independently among sites (except for
        the auto-discrete-gamma model which account for
        correlated substitution rates at neighboring sites); </li>
    <li>The process of substitution is described by a
        time-homogeneous Markov process. Further restrictions may
        be placed on the structure of the <i>rate matrix </i>of
        the process and lead to different substitution models; </li>
    <li>The process of substitution is stationary. In other
        words, the frequencies of nucleotides (<code>baseml</code>),
        codons (<code>codonml</code>), or amino acids (<code>aaml</code>)
        have remained constant over the time period covered by
        the data. </li>
</ul>

<p>The existence of a molecular clock (rate constancy among
lineages) is not necessary but can be imposed. Variation (and
dependence) of rates at sites is allowed by the discrete-gamma
(or auto-discrete-gamma) models implemented in <code>baseml</code>,
<code>codonml</code> and <code>aaml</code>. </p>

<p>The sequences must be aligned, and sites involving gaps will
be removed from all sequences before analysis, with appropriate
adjustment to the sequence length. </p>

<h1><a href="#toc">Files in the Package</a></h1>

<p>The following files are included in the package:</p>

<p><i>Source codes: </i></p>

<dir>
    <li><pre>
baseml.c    various models for nucleotide sequences 
codeml.c    models for codon (seqtype = 1) and amino acid (seqtype = 2) sequences 
pamp.c      parsimony analyses of nucleotide or amino acid sequences 
mcmctree.c  Markov chain Monte Carlo algorithm for Bayes estimation of phylogenies 
evolver.c  Tree comparison, and simulation of nucleotide sequences 
basemlg.c   Nucleotide-based model with (continuous) gamma rates among sites 
rell.c      The RELL approximate bootstrap method of Kishino and Hasegawa (1989)
treesub.c   a few functions 
treespace.c a few more functions 
tools.c     my toolkit 
tools.h     header file 
eigen.c     routines for calculating eigen values and vectors
</pre>
    </li>
</dir>

<p><i>Compiling commands: </i></p>

<dir>
    <li><pre>
Makefile    make file
paml.cc     batch file for compiling PAML using the cc compiler 
paml.gcc    batch file for compiling PAML using the GNU gcc compiler 
paml.acc    batch file for compilation PAML using the SUN acc compiler
</pre>
    </li>
</dir>

<p><i>Control files: </i></p>

<dir>
    <li><pre>
baseml.ctl    control file for running baseml and basemlg 
codeml.ctl    control file for codeml (i.e., codonml and aaml) 
pamp.ctl      control file for pamp 
mcmctree.ctl  control file for mcmctree
</pre>
    </li>
</dir>

<p><i>Data files for </i><code><i>codeml</i></code><i> (see the
files for details): </i></p>

<dir>
    <li><pre>
grantham.dat   amino acid distance matrix (Grantham 1974), used by codonml 
miyata.dat     amino acid distance matrix (Miyata et al. 1980), used by codonml 
dayhoff.dat    Empirical amino acid substitution matrix of Dayhoff et al. (1978) 
jones.dat      Empirical amino acid substitution matrix of Jones et al. (1992) 
mtREV24.dat    Empirical amino acid substitution matrix of Adachi and Hasegawa (1996b) 
mtmam.dat      Empirical amino acid substitution matrix for mitochondrial proteins of mammals
MCbase.dat     data file for simulating nucleotide sequences, for evolver
MCcodon.dat    data file for simulating codon sequences, for evolver
MCcodon.dat    data file for simulating amino acid sequences, for evolver
</pre>
    </li>
</dir>

<p><i>Example tree structure files: </i></p>

<dir>
    <li><pre>
4s.trees      tree structure file for 4-sequence data 
5s.trees      tree structure file for 5-sequence data
</pre>
    </li>
</dir>

<p><i>Documentations: </i></p>

<dir>
    <li><pre>
paml.readme    readme file 
paml.html      paml web page, serving also as part of the manual (html file) 
pamlDOC.html   this document (html file)
</pre>
    </li>
</dir>

<p><i>Example data sets: </i>Several example data sets are
included. They were used in my papers to test new methods, and
are included here for error-checking. </p>

<dir>
    <li><code>brown.nuc</code>: the 895-bp mtDNA data of Brown et
        al. (1982), used in Yang et al. (1994) and Yang (1994c)
        to test models of variable rates among sites. <p><code>mtprim9.nuc</code>:
        mitochondrial segment consisting 888 aligned sites from 9
        primate species (Hayasaka et al. 1988), used by Yang
        (1994c) to test the discrete-gamma model and Yang (1995)
        to test the auto-discrete-gamma models. </p>
        <p><code>abglobin.nuc</code>: the concatenated alpha and
        beta globin genes, example data for condonml </p>
        <p><code>HIVenvY7.nuc</code>: HIV envelope genes, year 7
        data, used by Nielsen and Yang (1998) in developing
        models of variable seletive constraints among sites. </p>
        <p><code>lysozymeSmall.nuc</code>: primate lysozyme genes
        (Messier and Stewart 1997), analyzed by Yang (1998) in
        developing tests of positive selection along lineages.
        This is the &quot;small data set&quot; analyzed in that
        paper. See the control file <code>lysozyme.ctl</code> for
        details for specifying the different models.</p>
        <p><code>stewart.aa</code>: lysozyme sequences of mammals
        (Stewart et al. 1987), used by Yang et al. (1995) to test
        methods for reconstructing ancestral amino acid
        sequences. </p>
        <p><code>abglobin.aa</code>: the concatenated alpha- and
        beta-globins, translated from <code>abglobin.nuc</code> </p>
    </li>
</dir>

<p><b>Which files are needed?</b></p>

<p>You may copy the executables to a directory containing your
data files. Please note that the program <code>codeml</code> may
need some of the data files in the package such as <code>grantham.dat</code>,
<code>dayhoff.dat</code>, <code>jones.dat</code>, <code>mtREV24.dat</code>,
or <code>mtmam.dat</code>. You should probably copy these files
together. Other programs do not need such data files apart from
the sequence and tree files you specify in the control file. </p>

<p>Note also that the programs produce result files. Some other
files with names <code>rub</code>, <code>lfh</code>, <code>rst</code>,
or <code>rates</code> may also be created. You should not use
these names for your files. </p>

<h1><a href="#toc">Running the Programs</a></h1>

<p>The basics of running programs in the package are discussed in
the PAML web page. Here are a few more tips. </p>

<p>The iteration process, i.e., the minimization of the negative
log-likelihood, is recorded in <code>rub</code>. For each round
of iteration, the size (norm) of the gradient or search direction
(h), the negative log likelihood, and the current values of
parameters are listed. A healthy iteration is indicated by the
decrease of both h and the negative log likelihood, and h is
particularly sensitive. This file should be checked to ensure the
convergence of the algorithm. A typical symptom of failure of the
algorithm is that estimates of parameters are at the preset
boundaries, with values like 2.00000, 5.00000. </p>

<h2><a name="finetuning">Finetuning the iteration algorithm</a></h2>

<p>The iteration algorithm uses the difference approximation to
calculate the derivatives. This method changes the variable (x)
slightly, say by a small number e, and see how the function value
changes. One such formula is df/dx = [f(x + e) - f(x)]/e. The
small number e should be small to allow accurate approximation
but should not be too small to avoid rounding errors. You can
change this value by adding a line in the control files <code>baseml.ctl</code>
or <code>codeml.ctl</code> <br>
</p>

<pre>
	Small_Diff = 1e-6
</pre>

<p>The iteration is rather sensitive to the value of this
variable, and reasonable values are between 1e-5 and 1e-7. This
variable also affects the calculation of the SE's for parameters,
which are much more difficult to approximate than the first
derivatives. If the calculated SE's are sensitive to slight
change in this variable, they are not reliable. </p>

<p>If you compile the source codes, you can also change the lower
and upper bounds for parameters. I have not put these variables
into the control files. See the section on <a href="#variables">Adjustable
variables</a>. </p>

<h2><a name="initials">Initial values</a></h2>

<p>You may change values of parameters in the control file such
as kappa, alpha, omega, etc. to start the iteration from
different initial values. Initial values for the second and later
trees are determined by the program, and so you do not have much
control in this way.</p>

<p>You can collect initial values into a file called <code>in.baseml</code>
if you are running <code>baseml</code> or <code>in.codeml</code>
if you are running <code>codeml</code>. When the program senses
this file, it will ask you to confirm and then read it for
initial values. This may be useful if the iteration is somehow
aborted, and then you can collect current values of parameters
from the file <code>rub</code> into this file of initial values,
so that the new iteration can have a better start and may
converge faster. This file may also be useful if you experience
convergence problems as it allows you to start from different
initial values in different runs. If you have already obtained
parameter estimates before and do not want the program to
re-estimate them and only want to do some analysis base on those
estimates such as reconstructing ancestral sequences, insert -1
before the initial values. </p>

<p>The <code>rub</code> file records the iteration process and
has one line for each round of iteration. Each line lists the
current parameter values after the symbol x; you can copy those
numbers into the file of initial values, and if you like, change
one or a few of the parameter values too. </p>

<h2><a name="basemlg">Running <code>basemlg</code></a></h2>

<p>Because of the intensive computation required by <code>basemlg</code>,
the discrete-gamma model implemented in baseml is recommended for
data analysis. If you choose to use basemlg, you should run <code>baseml</code>
first, and then run <code>basemlg.</code> This allows <code>baseml</code>
to collect initial values into a file named <code>in.basemlg</code>,
for use by <code>basemlg</code>. You can also check the file <code>rub</code>
to see the iteration converges healthily. Note that <code>basemlg</code>
implements only a subset of models in <code>baseml</code>. </p>

<h2><a name="macmemory">MAC memory allocation</a></h2>

<p>When your data set is large, you may see a message like
&quot;oom &quot;, which stands for &quot;out of memory&quot;. If
you think your data set should be manageable by the
program/computer, you can change the memory that is allowed by
the operating system for the program to use. If you select the
file name and choose &quot;File-Get information&quot;, you should
see a pop up window. You can increase numbers in this window. </p>

<h2><a name="winwindow">Windows version window auto-close</a></h2>

<p>Run the Windows version from a DOS/Windows command box by
typing the program names such as <code>baseml</code>. Do not run
the programs by double clicking on the file names from Windows
95/NT Explorer. Otherwise, the window will close automatically
when the programs finish or abort and you won't have the chance
to see any error messages. I would consider this as a bug of the
Microsoft OS, but perhaps it is considered a feature. </p>

<h1><a href="#toc">Input File Formats</a></h1>

<h2><a name="sequences">Sequence data format</a></h2>

<p>The sequence data format is that used in PHYLIP (Felsenstein,
1993). The first line contains the number of species and the
sequence length (possibly followed by option characters). With <code>codonml</code>
(<code>codeml</code> with <code>seqtype</code> = 1), the sequence
length in the sequence file refers to the number of nucleotides
rather than the number of codons. The only options allowed in the
sequence file are I, S or G. The sequences may be in either <i>interleaved
</i>format (option I, example data file <code>abglobin.nuc</code>),
or <i>sequential </i>format (option S, example data file <code>brown.nuc</code>).
The default option is S. (Option G is used for combined analysis
of multiple gene data and is explained below.) The following is
an example data set in the sequential format. It has 4 sequences
each of 60 nucleotides. </p>

<dir>
    <li><pre>
 4  60 
sequence 1 
AAGCTTCACCGGCGCAGTCATTCTCATAAT 
CGCCCACGGACTTACATCCTCATTACTATT 
sequence 2 
AAGCTTCACCGGCGCAATTATCCTCATAAT 
CGCCCACGGACTTACATCCTCATTATTATT 
sequence 3 
AAGCTTCACCGGCGCAGTTGTTCTTATAAT 
TGCCCACGGACTTACATCATCATTATTATT 
sequence 4 
AAGCTTCACCGGCGCAACCACCCTCATGAT 
TGCCCATGGACTCACATCCTCCCTACTGTT </pre>
    </li>
</dir>

<p><b>Species names.</b> Do not use special symbols like , : # (
) in a species name as they may confuse the programs. The maximum
number of characters in a species name (LSPNAME) is specifed at
the beginning of the main programs <code>baseml.c</code> and <code>codeml.c</code>.
The default value is 30. In PHYLIP, exactly 10 characters are
used for a species name. You may change the value of LSPNAME to
10 in the source codes if you like. To make this discrepancy less
a problem, PAML considers two consecutive spaces as the end of a
species name, so that the species name does not have to have
exactly 30 (or 10) characters. To make this rule work, you should
not have two consecutive spaces <i>within</i> a species name. For
example the above data set can have the following format too. </p>

<dir>
    <li><pre>
 4  60 

sequence 1   AAGCTTCACCGGCGCAGTCATTCTCATAAT 
CGCCCACGGACTTACATCCTCATTACTATT 

sequence 2   AAGCTTCACCGGCGCAATTATCCTCATAAT 
CGCCCACGGACTTACATCCTCATTATTATT 
sequence 3      AAGCTTCACC GGCGCAGTTG TTCTTATAAT  TGCCCACGGACTTACATCATCATTATTATT 
sequence 4   AAGCTTCACCGGCGCAACCACCCTCATGAT 
TGCCCATGGACTCACATCCTCCCTACTGTT </pre>
    </li>
</dir>

<p>In a sequence, three special characters &quot;.&quot;,
&quot;-&quot;, and &quot;?&quot; may be used: a dot means the
same character as in the first sequence, a dash means an
alignment gap, and a question mark means an undetermined site.
Sites at which at least one sequence involves a &quot;-&quot; or
&quot;?&quot; are excluded from all sequences before analysis,
with the sequence length adjusted. For codon sequences, the whole
codon is removed. Characters T, C, A, G, U, t, c, a, g, u are
recognized as nucleotides (for <code>baseml</code>, <code>basemlg</code>
and <code>codonml</code>), while the standard one-letter codes
(A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V or
their lowercase equivalents) are used for amino acids. Other
alphabetic characters cause errors. Non-alphabetic symbols such
as &gt;&lt;!&quot;£$%^0123456789 are simply ignored and can be
freely used as landmarks. Lines do not have to be equally long
and you can put the whole sequence on one line. </p>

<p>Notes may be placed at the end of the sequence file and will
be ignored by the programs. </p>

<p><b>Option G: </b>This option is for combined analyses of
heterogeneous data sets such as data of multiple genes or data of
the three codon positions. The sequences must be concatenated and
the option is used to specify which gene or codon position each
site is from. There are two data formats with this option. The
first is illustrated by an excerpt of a sequence file listed
below. The example data of Brown <i>et al. </i>(1982) are an
895-bp segment from the mitochondrial genome, which codes for
parts of two proteins (ND4 and ND5) at the two ends and three
tRNAs in the middle. Sites in the sequence fall naturally into 4
classes: the three codon positions and the tRNA coding region.
The first line of the file contains the option character G. The
second line begins with a G at the first column, followed by the
number of site classes. The following lines contain the site
marks, one for each site in the sequence (or each codon in the
case of <code>codonml</code>). The site mark specifies which
class each site is from. If there are <i>g </i>classes, the marks
should be 1, 2, ..., <i>g</i>, and if <i>g </i>&gt; 9, the marks
need to be separated by spaces. The total number of marks must be
equal to the total number of sites in each sequence.</p>

<dir>
    <li><pre>
  5   895    G 
G   4 
3  
123123123123123123123123123123123123123123123123123123123123 
123123123123123123123123123123123123123123123123123123123123 
123123123123123123123123123123123123123123123123123123123123 
123123123123123123123123123123123123123123123123123123123123 
123123123123123123123123123123123123123123123123123123123123 
123123123123123123123123123123123123123123123123123123123123 
123123123123123123123123123123123123123123123123123123123123 
1231231231231231231231231231231231231 
444444444444444444444444444444444444444444444444444444444444 
444444444444444444444444444444444444444444444444444444444444 
444444444444444444444444444444444444444444444444444444444444 
444444444444444444 
123123123123123123123123123123123123123123123123123123123123 
123123123123123123123123123123123123123123123123123123123123 
123123123123123123123123123123123123123123123123123123123123 
12312312312312312312312312312312312312312312312312312312312 
Human 
AAGCTTCACCGGCGCAGTCATTCTCATAATCGCCCACGGACTTACATCCTCATTACTATT 
CTGCCTAGCAAACTCAAACTACGAACGCACTCACAGTCGCATCATAATC........ 
Chimpanzee 
......... 
</pre>
    </li>
</dir>

<p>If the data are concatenated sequences of multiple genes, a
simpler format, shown below for an example data set, may be used.
This sequence has 1000 nucleotides from 4 genes, obtained from
concatenating four genes with 100, 200, 300, and 400 nucleotides
from genes 1, 2, 3, and 4, respectively. The &quot;lengths&quot;
for the genes must be on the line that starts with G, <i>i.e.</i>,
on the second line of the sequence file. (This requirement allows
the program to determine which of the two formats is being used.)
The sum of the lengths for the genes should be equal to the
number of nucleotides, amino acids, or codons in the combined
sequence for <code>baseml</code> (or <code>basemlg</code>), <code>aaml</code>,
and <code>codonml</code>, respectively.</p>

<dir>
    <li><pre>
5   1000   G 
G 4    100 200 300 400 
Sequence 1  
TCGATAGATAGGTTTTAGGGGGGGGGGTAAAAAAAAA....... 
</pre>
    </li>
</dir>

<p>For analysis of protein-coding DNA sequences using <code>baseml</code>,
a third format is as follows. You use option characters GC on the
first line instead of G alone. It is assumed that the sequence
length is an exact multiple of three. </p>

<dir>
    <li><pre>
     5    855 GC
human    GTG CTG TCT CCT ...
</pre>
    </li>
</dir>

<h2><a name="trees">Tree structure file and representations of
the tree topology</a></h2>

<p>A <i>tree structure file</i> is used when <code>runmode</code>
= 0 or 1. The file name is specified in the appropriate control
file. Two methods for representing a tree topology are used in
PAML. The first is the familiar parenthesis representation, that
is used in virtually any phylogenetic software. The species can
be represented using either their names or their indexes
corresponding to the order of their occurrences in the sequence
data file. If species names are used, they have to match exactly
those in the sequence data file (including spaces or strange
characters). Branch lengths are allowed. The following is a
possible tree structure file for a data set of four species
(human, chimpanzee, gorilla, and orangutan, occurring in this
order in the data file). The first tree is a star tree, while the
next four trees are the same. </p>

<dir>
    <li><pre>
4  5              // 4 species, 5 trees 
(1234)            // the star tree 
((12)34)          // species 1 and 2 are clustered together 
((1,2),3,4)       // Commas are needed with more than 9 species 
((human,chimpanzee),gorilla,orangutan) 
((human:.1,chimpanzee:.2):.05,gorilla:.3,orangutan:.5) 
</pre>
    </li>
</dir>

<p>A second way of representing the tree topology used in PAML is
by means of its branches. This is mainly used in the result files
for outputting the estimated branch lengths. For example, the
tree ((12)34) is specified by its 5 branches: </p>

<dir>
    <li><pre>
      5 6,  6 1,  6 2,  5 3,  5 4
</pre>
    </li>
</dir>

<p>The nodes in a tree are marked with consecutive natural
numbers, with 1, 2, ..., <i>s</i> representing the <i>s</i> known
sequences, in the same order as in the data. A number larger than
<i>s</i> means an interior node, at which the sequence is
unknown. This representation saves space in the output in
comparison with a tree diagram but may make it difficult to
discern the topology when there are many species. In case some
sequences in the data are ancestral to some others, this method
is convenient. To use this format in the tree structure file,
give the number of branches, and then the branches as specified
by the end nodes. For example, the tree in the following <code>5s.trees</code>
file has 4 branches, with taxon 5 to be the common ancestor of
taxa 1, 2, 3, and 4: </p>

<dir>
    <li><pre>
5  1 
4     5 1   5 2   5 3   5 4 
</pre>
    </li>
</dir>

<p>Whether the tree will be considered rooted or unrooted depends
on whether a molecular clock is assumed. Without the clock, the
trees are unrooted, and so ((12)34) is the same as (12(34)); with
the clock, the trees are rooted and these two trees are different
and both are different from (((12)3)4). </p>

<h2><a name="baseml.ctl">The control file for programs <code>baseml</code>
and <code>basemlg</code></a></h2>

<p>The default control file for <code>baseml</code> and <code>basemlg</code>
is <code>baseml.ctl</code>, and an example is shown below. Note
that spaces are required on both sides of the equal sign, and
blank lines or lines beginning with &quot;*&quot; are treated as
comments. Options not used can be deleted from the control file. </p>

<dir>
    <li><pre>
      seqfile = brown.nuc * sequence data file name  
      outfile = mlb       * main result file 
     treefile = brown.trees  * tree structure file name 

        noisy = 3   * 0,1,2,3: how much rubbish on the screen 
      verbose = 1   * 1: detailed output, 0: concise output 
      runmode = 0   * 0: user tree;  1: semi-automatic;  2: automatic 
                    * 3: StepwiseAddition; (4,5):PerturbationNNI   

        model = 4   * 0:JC69, 1:K80, 2:F81, 3:F84, 4:HKY85, 5:TN93, 6:REV 
        Mgene = 0   * 0:rates, 1:separate; 2:diff pi, 3:diff kapa, 4:all diff   
    fix_kappa = 0   * 0: estimate kappa; 1: fix kappa at value below 
        kappa = 10   * initial or fixed kappa    

    fix_alpha = 0   * 0: estimate alpha; 1: fix alpha at value below 
        alpha = 0.5  * initial or fixed alpha, 0:infinity (constant rate) 
       Malpha = 0   * 1: different alpha's for genes, 0: one alpha 
        ncatG = 8   * # of categories in the dG, AdG, or nparK models of rates  

  
      fix_rho = 1   * 0: estimate rho; 1: fix rho at value below  
          rho = 0.  * initial or fixed rho,   0:no correlation 
        nparK = 0   * rate-class models. 1:rK, 2:rK&amp;fK, 3:rK&amp;MK(1/K), 4:rK&amp;MK   

  
        clock = 0   * 0: no clock, unrooted tree, 1: clock, rooted tree 
        nhomo = 0   * 0 &amp; 1: homogeneous, 2: kappa for branches, 3: N1, 4: N2 
        getSE = 0   * 0: don't want them, 1: want S.E.s of estimates 
 RateAncestor = 0   * (1/0): rates (alpha&gt;0) or ancestral states (alpha = 0) 

</pre>
    </li>
</dir>

<p>The control variables are described below. </p>

<p><code>seqfile</code>, <code>outfile</code>, and <code>treefile</code>,
specifies the names of the sequence data file, main result file,
and the tree structure file, respectively.</p>

<p><code>noisy</code> controls how much output you want on the
screen. If the model being fitted involves much computation, you
can choose a large number for <code>noisy </code>to avoid
loneliness. <code>verbose</code> controls how much output in the
result file.</p>

<p><code>runmode</code> = 0 means evaluation of the tree
topologies specified in the tree structure file only, <code>runmode</code>
= 1 or 2 means heuristic tree search by the star-decomposition
algorithm. With <code>runmode</code> = 2, the algorithm starts
from the star tree, while if <code>runmode</code> = 1, the
program will read a multifurcating tree from the tree structure
file and try to estimate the best bifurcating tree compatible
with it. <code>runmode</code> = 3 means stepwise addition. <code>runmode</code>
= 4 means NNI perturbation with the starting tree obtained by a
parsimony algorithm, while <code>runmode</code> = 5 means NNI
perturbation with the starting tree read from the tree structure
file. The tree search options do not work well, and so use <code>runmode</code>
= 0 as much as you can. </p>

<p><code>model</code> specifies the model of nucleotide
substitution.</p>

<p><code>Mgene</code> is used with the option G in the data file.
Choose 0 if option G is not used in the data file. </p>

<p><code>fix_kappa</code> specifies whether <font face="Symbol">k</font>
in K80, F84, or HKY85 is given at a fixed value or is to be
estimated by iteration from the data. If <code>fix_kappa</code> =
1, the value of another variable, <code>kappa</code>, is the
given value, and otherwise the value of <code>kappa</code> is
used as the initial estimate for iteration. The variables <code>fix_kappa</code>
and <code>kappa</code> have no effect with JC69 or F81 which does
not involve such a parameter, or with TN93 and REV which have two
and five rate parameters respectively and all of them are
estimated from the data.</p>

<p><code>fix_alpha</code> and <code>alpha</code> work in a
similar way, where <code>alpha</code> refers to the shape
parameter <font face="Symbol">a</font> of the gamma distribution
for variable substitution rates across sites (Yang 1994c). The
model of a single rate for all sites is specified as <code>fix_alpha</code>
= 1 and <code>alpha</code> = 0 (0 means infinity), while the
(discrete-) gamma model is specified by a positive value for <code>alpha</code>,
and <code>ncatG</code> is then the number of categories for the
discrete-gamma model (<code>baseml</code>). </p>

<p><code>fix_rho</code> and <code>rho</code> work in a similar
way and concern independence or correlation of rates at adjacent
sites, where <font face="Symbol">r</font> (rho) is the
correlation parameter of the auto-discrete-gamma model (Yang
1995). The model of independent rates for sites is specified as <code>fix_rho</code>
= 1 and <code>rho</code> = 0; choosing <code>alpha</code> = 0
further means a constant rate for all sites. The
auto-discrete-gamma model is specified by positive values for
both <code>alpha</code> and <code>rho</code>. The model of a
constant rate for sites is a special case of the (discrete) gamma
model with <font face="Symbol">a</font> = <font size="2"
face="Symbol">¥</font> (<code>alpha</code> = 0), and the model
of independent rates for sites is a special case of the
auto-discrete-gamma model with <font face="Symbol">r</font> = 0 (<code>rho</code>
= 0).</p>

<p><code>nparK</code> specifies nonparametric models for variable
and Markov-dependent rates across sites: <code>nparK</code> = 1
or 2 means several (<code>ncatG</code>) categories of independent
rates for sites, while <code>nparK</code> = 3 or 4 means the
rates are Markov-dependent at adjacent sites; <code>nparK</code>
= 1 and 3 have the restriction that each rate category has equal
probability while <code>nparK</code> = 2 and 4 do not have this
restriction (Yang, 1995). The variable <code>nparK</code> takes
precedence over <code>alpha</code> or <code>rho</code>. </p>

<p><code>clock</code> specifies whether we assume rate constancy
along different branches in the tree (<code>clock</code> = 1) or
variable rates among lineages (<code>clock</code> = 0). The
estimated branch lengths are in the output tree. </p>

<p><code>nhomo</code> relates to the non-homogeneous process
models (<code>nhomo</code> = 3 or 4) (Yang and Roberts 1995).
Choosing <code>nhomo</code> = 1 will produce the proper maximum
likelihood estimates of the frequency parameters (<font
face="Symbol">p</font><sub>T</sub>, <font face="Symbol">p</font><sub>C</sub>
and <font face="Symbol">p</font><sub>A</sub>; <font face="Symbol">p</font><sub>G</sub>
is not a free parameter as the frequencies sum to 1) in the F81,
F84, HKY85, TN93, or REV models, while normally (<code>nhomo</code>
= 0) these are estimated by the averages of the observed
frequencies. <code>nhomo</code> = 2 uses one
transition/transversion rate ratio (<font face="Symbol">k</font>)
for each branch in the tree for the K80, F84, and HKY85 models
(Yang 1994b). <code>nhomo</code> = 3 and 4 implements the
nonhomogeneous models discussed by Yang and Roberts (1995). When <code>nhomo</code>
= 3 or 4, the option <code>fix_kappa = 1</code> means one kappa
for all branches, and <code>fix_kappa = 0</code> means one kappa
for each branch. </p>

<p><code>getSE</code> tells whether we want estimates of the
standard errors of estimated parameters. These are crude
estimates, calculated by the curvature method, <i>i.e.</i>, by
inverting the matrix of second derivatives of the log-likelihood
with respect to parameters. The second derivatives are calculated
by the difference method, and are not always reliable. Even if
this approximation is reliable, tests relying on the SE's should
be taken with caution, as such tests rely on the normal
approximation to the maximum likelihood estimates. The likelihood
ratio test should always be preferred. The option is not
available and choose <code>getSE = 0</code> when tree-search is
performed (<code>runmode</code> = 1 or 2). </p>

<p><code>RateAncestor</code> also works with <code>runmode</code>
= 0 only. For models of gamma rates across sites, the option
RateAncestor = 1 calculates rates for sites along the sequence
and also does the marginal ancestral reconstruction. For models
of one rate for all sites, <code>RateAncestor = 1</code> does
both marginal and joint ancestral sequence reconstruction. Since
the ancestral reconstruction generates large output files, you
should inspect the file before directing it to the printer. You
can also use the variable <code>verbose</code> to control the
amount of output. If you choose <code>verbose</code> = 0, the
program will list the best nucleotide at each node for the
variable sites only and results for constant sites are
suppressed. If <code>verbose</code> = 1, the program will list
all sites for the best nucleotide at each node. If <code>verbose</code>
= 2, the program also lists the full posterior
probabilitydistribution for each site at each ancestral node (for
marginal reconstruction). </p>

<p>Sine the joint reconstruction may miss important
reconstructions except for small data sets, I have added an
option for the user to specify the reconstruction to be
evaluated. Specify RateAncestor = 2, and you will be prompted to
specify the site and the reconstruction to be evaluated.</p>

<p>For nucleotide based analysis of protein coding DNA sequences,
I have added the calculation of posterior probabilities of
ancestral amino acids. In this analysis, branch lengths and other
parameters are estimated under a nucleotide substitution model,
but the reconstructed nucleotide triplets are examined to infer
the most likely amino acid encoded by the triplet. Posterior
probabilities for stop codons are small and reset to zero to
scale the posterior probabilities for amino acids. To use this
option, you need add the control variable icode in the control
file <code>baseml.ctl</code>. This is a funny option variable and
so is not listed in the above list. <code>icode</code> can take a
value out of 0, 1, ..., 10, corresponding to the 11 genetic codes
included in paml (See the control file <code>codeml.ctl</code>
for the definition of different genetic codes). A nucleotide
subsitution model that is very close to a codon-substitution
model can be specified as follows. You add the option characters
GC at the end of the first line in the data file and choose model
= 4 (HKY85) and Mgene = 4. The model then assumes different
substitution rates, different base frequencies, and different
transition/transversion rate ratio (kappa) for the three codon
positions. Ancestral reconstruction from such a nucleotide
substitution should be very similar to codon-based
reconstruction. </p>

<p>With <code>basemlg</code>, tree-search or the assumption of a
molecular clock are not allowed and so choose <code>runmode = 0</code>
and <code>clock = 0</code>. Substitution models available for
basemlg are JC69, F81, K80, F84 and HKY85, and a continuous gamma
is always assumed for rates at sites. The variables <code>ncatG</code>,
<code>given_rho</code>, <code>rho</code>, <code>nhomo </code>have
no effect. The S.E.'s of parameter estimates are always printed
out because they are calculated during the iteration, and so
getSE has no effect. </p>

<h2><a name="codeml.ctl">The control file for the program <code>codeml</code>
(<code>codonml</code> and <code>aaml</code>) </a></h2>

<p>Since the codon based analysis and the amino acid based
analysis use different models, and some of the control variables
have different meanings, it may be a good idea to use different
control files for codon and amino acid sequences. The default
control file for <code>codeml</code> is <code>codeml.ctl</code>,
as shown below.</p>

<pre>
     seqfile = stewart.aa * sequence data file name 
     outfile = mlc         * main result file name 
    treefile = stewart.trees    * tree structure file name  

       noisy = 3   * 0,1,2,3,9: how much rubbish on the screen 
     verbose = 0   * 1: detailed output, 0: concise output 
     runmode = 0   * 0: user tree;  1: semi-automatic;  2: automatic 
                   * 3: StepwiseAddition; (4,5):PerturbationNNI   

     seqtype = 2   * 1:codons; 2:AAs; 3:codons--&gt;AAs 
   CodonFreq = 2   * 0:1/61 each, 1:F1X4, 2:F3X4, 3:codon table 
      aaDist = 0   * 0:equal aa distance, 1: Grantham1974 (for codon models)  

  aaRatefile = jones.dat  * only used for aa seqs and when model = empirical(_F)   
                          * dayhoff.dat, jones.dat, mtmam.dat, or your own 
       model = 2 
                    * models for codons: 
                      *  0:one N/S rate, 1: b ratios, 2: 2 or more ratios 
                    * models for AAs or codon-translated AAs: 
                      *  0:poisson, 1:equal_input, 2:Empirical, 3:Empirical+F 
                      *  6:FromCodon, 7:AAClasses, 8:REVaa_0, 9:REVaa(nr = 189)  

      NSsites = 0   * dN/dS among sites. 0:no variation, 1:neutral, 2:positive 
        icode = 0   * 0:standard genetic code; 1:mammalian mt; 2-10:below 
        Mgene = 0   * 0:rates, 1:separate; 2:pi, 3:kappa, 4:all 

    fix_kappa = 0   * 1: kappa fixed, 0: kappa to be estimated 
        kappa = 4.6 * initial or fixed kappa 
    fix_omega = 0   * 1: omega or omega_1 fixed, 0: estimate  
        omega = 1   * initial or fixed omega, for codons or codon-transltd AAs  


    fix_alpha = 1   * 0: estimate gamma shape parameter; 1: fix it at alpha 
        alpha = 0.  * initial or fixed alpha, 0:infinity (constant rate) 
       Malpha = 0   * different alphas for genes  
        ncatG = 8   * # of categories in the dG or AdG models of rates  

      fix_rho = 1   * 0: estimate rho (correlation parameter); 1: fix it at rho 
          rho = 0.  * initial or fixed rho,   0:no correlation  

        clock = 0   * 0: no clock, unrooted tree, 1: clock, rooted tree 
        getSE = 0   * 0: don't want them, 1: want S.E.s of estimates 
 RateAncestor = 0   * (1/0): rates (alpha&gt;0) or ancestral states (alpha = 0) 
</pre>

<p>The variables <code>seqfile</code>, <code>outfile</code>, <code>treefile</code>,
<code>noisy</code>, <code>Mgene</code>, <code>fix_alpha</code>, <code>alpha</code>,
<code>Malpha</code>, <code>fix_rho</code>, <code>rho</code>, <code>clock</code>,
<code>getSE</code> and <code>RateAncestor</code> are used in the
same way as in <code>baseml.ctl</code> and are described in the
previous section. The variable <code>seqtype</code> specifies the
type of sequences in the data; <code>seqtype</code> = 1 means
codon sequences (the program is then <code>codonml</code>); 2
means amino acid sequences (the program is then <code>aaml</code>);
and 3 means codon sequences which are to be translated into
proteins for analysis. </p>

<p><b>codon sequences (</b><code><b>seqtype</b></code><b> = 1):</b>
<code>CodonFreq</code> specifies the equilibrium codon
frequencies in the model of Goldman and Yang (1994). These
frequencies can be assumed to be equal (1/61 each for the
standard genetic code, <code>CodonFreq</code> = 0), calculated
from the average nucleotide frequencies (<code>CodonFreq</code> =
1), from the average nucleotide frequencies at the three codon
positions (<code>CodonFreq</code> = 2), or used as free
parameters (<code>CodonFreq</code> = 3). The variable <code>aaDist</code>
determines whether equal amino acid distances are assumed (= 0)
or Grantham's matrix is used (= 1) (Yang et al. 1998). </p>

<p>The variable <code>model</code> concerns assumptions about the
<i>d</i><sub>N</sub>/<i>d</i><sub>S</sub> rate ratios (or the <code>omega</code>
parameters) among branches (Yang 1998; Yang and Nielsen 1998).
The value 0 means one <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub>
ratio for all lineages (branches), 1 means one ratio for each
branch (the free-ratio model), and 2 means an arbitrary number of
ratios (such as the 2-ratios or 3-ratios models). When <code>model
= 2</code>, the program asks the user to input a branch mark for
the <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub> ratio assumed for
each branch. This should be a integral number between 0 to <i>k</i>
- 1 if <i>k</i> different <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub>
ratios (<font face="Symbol">w</font><sub>0</sub> - <font
face="Symbol">w</font><sub><i>k</i> - 1</sub>) are assumed for
the branches of the tree. This process should be frustrating if
the tree is not very small. I run the program first to let it
output the tree topology using the branch representation on the
screen. I then prepare the branch marks in a file, say, <code>in</code>.
Finally I run the program using redirection so that it will read
the input from the prepared file </p>

<pre>
    codeml <in </pre>
Redirection is not permitted on a MAC, but I suppose you can prepare
the branch marks in a file and then copy and paste them into the
session running the program.  Furthermore, under this model, the
variable <code>fix_omega </code>fixes the
last<i>d</i><sub>N</sub>/<i>d</i><sub>S</sub> ratio (<font
face="Symbol">w</font><sub><i>k</i> - 1</sub>) at the value of
<code>omega</code> specified in the file.  This option can be used to
test, for example, whether the ratio for a specific lineage is
significantly different from one.  Check the example data file
<code>lysozymeSmall.nuc</code> and the control file <code>
lysozyme.ctl</code> and try to reproduce results published in
Yang (1998).
</pre>

<p><code>Nssites</code> specifies a few models that allow the <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub>
ratio to vary among sites (Nielsen and Yang 1998). <code>NSsites</code>
= 0, which means one ratio for all sites, should normally be
used. <code>NSsites</code> = 1 specifies a neutral model which
has two categories of sites at which the <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub>
rate ratio is either 1 (neutral sites) or 0 (conserved sites).
The parameter in this model is the proportion of neutral sites. <code>NSsites</code>
= 2 specifies a selection model with an additional category of
sites at which the <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub> rate
ratio is &gt; 1. Parameters under this model include the
proportions of neutral and conserved sites (<i>p</i><sub>1</sub>
and <i>p</i><sub>2</sub>) and the <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub>
rate ratio at the selected sites. Equal amino acid distances are
used, and the <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub> ratio is
equal to parameter <font face="Symbol">w</font> in equation 9
(see the Models and Methods section below). This model is noted
to be prone to the problem of multiple local optima, and I have
come across cases where there are two local optima, one with 0 <w3 < 1 and another with w3>
1. You are advised to run the program at least twice twice, once
with an <code>omega</code> value <1 and a second time with an <code>omega value &gt; 1, and use the
results corresponding to the highest likelihood. The continuous
neutral and selection models of Nielsen and Yang (1998) are not
implemented in the program, but hopefully some equivalent models
will be implemented soon. The most likely <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub>
ratio classes for sites when <code>NSsites</code> = 1 or 2 are in
the file <code>rst</code>.</p>

<p>The genetic code table is selected using <code>icode</code>.
About a dozen genetic code tables are implemented, with 0
standing for the standard code and 1 for the mammalian
mitochondrial code (see notes at the end of <code>codeml.ctl</code>).</p>

<p>Ancestral reconstructions under amino acid models are rather
similar to nucleotide based analysis. For codon sequences,
ancestral reconstruction is not implemented for the models of
variable dN/dS ratios among sites. The output under codon-based
models usually shows the encoded amino acid for each codon. The
output under &quot;Prob of best character at each node, listed by
site&quot; has two posterior probabilities for each node at each
codon (amino acid) site. The first is for the best codon. The
second, in parentheses, is for the most likely amino acid under
the codon substitution model. This is a sum of posterior
probabilities across synonymous codons. For example, the
following are data at a site for the abglobin.nuc data set which
has 5 species and 3 ancestral nodes. The reconstructed codon for
the first ancestral node is GTG, which codes for V and has
probability 0.993. The most likely amino acid is V with
probability 1.000. The latter probability is higher because it
includes other synonymous codons that encode V. In theory it is
possible although rare for the most likely amino acid not to
match the most likely codon. Let me know if you get an example.</p>

<pre>
   1 9 GTG (V) GTG (V) GTG (V) GTG (V) GTG (V) : 
       GTG V 0.993 (V 1.000) GTG V 0.998 (V 1.000) GTG V 0.996 (V 1.000)
</pre>

<p><b>Amino acid sequences (</b><code><b>seqtype</b></code><b> =
2 or 3):</b> The variable <code>model</code> specifies the model
of amino acid substitution: 0 for the Poisson model assuming
equal rates for any amino acid substitutions (Bishop and Friday,
1987); 1 for the proportional model in which the rate of change
to an amino acid is proportional to the frequency of that amino
acid. <code>Model</code> = 2 specifies a class of empirical
models, and the empirical amino acid substitution rate matrix is
given in the file specified by <code>aaRatefile</code>. Files
included in the package are for the empirical models of Dayhoff <i>et
al</i>. (1978) (dayhoff.dat) and Jones <i>et al</i>. 1992
(jones.dat) (see Kishino <i>et al.</i>, 1990 for the
construction). The file <code>mtmam.dat</code> has a matrix for
mitochondrial proteins estimated by maximum likelihood from a
data set of 20 mammals. The mtREV24 model of the MOLPHY package
is also provided (the file <code>mtREV24.dat</code>). They two
models are similar, and the difference is that the former is
derived from proteins from mammals only while the latter came
from more-diverse species including chicken, fish, frog, and
lamprey. Due to differences in the implementation, you may see
small differences in log-likelihood values and branch lengths
between <code>codeml</code> and <code>protml</code> in the MOLPHY
package. Such differences are normal and you should use the same
program to compare different trees. Under the mtREV24 model, the
two programs should give almost identical results. </p>

<p>If you hope to specify your own substitution rate matrix, have
a look at one of those files, which has notes about the file
structure. Other options for the amino acid substitution model
should be ignored.</p>

<p>To summarize, the variables <code>model</code>, <code>aaDist</code>,
<code>CodonFreq</code>, <code>NSsites</code>, and <code>icode</code>
are used for codon sequences (seqtype = 1), while <code>model</code>
and <code>aaRatefile</code> are used for amino acid sequences.</p>

<p><code>runmode</code> also works in the same way as in <code>baseml.ctl.</code>
However, <code>runmode</code> = -2 for <code>codonml</code>
forces the program to calculate the numbers of synonymous (<i>d</i><sub>S</sub>)
and nonsynonymous (<i>d</i><sub>N</sub>) substitutions per site
for all pairwise sequence comparisons. The numbers of synonymous
(<i>S</i>) and nonsynonymous (<i>N</i>) sites in each pairwise
comparison are also calculated, scaled so that they sum to the
total number of nucleotides in the sequence. The method of
Goldman and Yang (1994) is used. You can choose different values
for <code>CodonFreq</code> for this calculation.</p>

<p>For amino acid sequences, the option <code>runmode</code> = -2
is for calculating ML distances in pairwise comparisons. You can
change the following variables in the control file <code>codeml.ctl</code>:
<code>runmode, aaRatefile, model, and alpha</code>. </p>

<p>If you do pairwise ML comparison (<code>runmode</code> = -2)
and the data contain ambiguity characters or alignment gaps, the
program will remove all sites which have such characters from all
sequences before the pairwise comparison if <code>cleandata</code>
= 1. This is known as &quot;complete deletion&quot;. It will
remove alignment gaps and ambiguity characters in each pairwise
comparsion (&quot;pairwise&quot; deletion) if <code>cleandata</code>
= 0. (In a likelihood analysis of multiple sequences on a
phylogeny, alignment gaps are treated as ambiguity characters if <code>cleandata</code>
= 0, and both alignment gaps and ambiguity characters are deleted
if <code>cleandata</code> = 1. Note that removing alignment gaps
and treating them as ambiguity characters both underestimate
sequence divergences. Ambiguity characters in the data make the
likelihood calculations quite a bit slower. </p>

<h2><a name="mcmctree.ctl">The control file for the program <code>mcmctree</code>
</a></h2>

<pre>The default control file name is <code>mcmctree.ctl</code>, and a sample copy is shown below.

</pre>

<dir>
    <li><pre>
    seqfile    = mtprim9.nuc    * sequence data file name
    outfile    = mcmctree.out     * main result file name
    treefile   = 9s.trees      * tree structure file name 
    LHfile     = Lhs    * LH file name. read (MCMC=0) or overwritten (MCMC=1)
      MCMC     = 0      *0: read LHs from LHfile, 1: use MCMC to generate Lhs
      beta     = 0.15    * prob{change labeled history}, used only if MCMC=1 
    delta0     = 1       * small number for MCMC, used only if MCMC=1 
    delta1     = .2       * smaller number for comparing candidate LHs

     model     = 2    * 0:JC69, 1:K80, 2:F81, 3:F84, 4:HKY85

     kappa     = 2.    * given kappa and omega in GY94.
     alpha     = 0    * given alpha, 0:infinity
     ncatG     = 8    * # of categories in the dG or AdG models of rates

     hierarch  = 0    * 1:hierarchical; 0:empirical Bayes analysis
     birth     = 6.7    * lineage birth rate
     death     = 2.5    * lineage death rate
     sample    = .06    * sampling proportion
     mutate    = .24    * mutation rate (# of mutations from root to present)
</pre>
    </li>
</dir>

<pre>The variables <code>seqfile</code>, <code>outfile</code>,
<code>treefile</code>, <code>model</code>, <code>kappa</code>, <code>alpha</code>, and <code>ncatG</code> are defined as in
<code>baseml.ctl</code> for program <code>baseml</code>.  The program first collects a set of candidate labeled histories.  If
<code>MCMC</code> = 0, the candidate labeled histories are read from the
file <code>LHfile</code>, while if <code>MCMC</code> = 1, they are generated from the Markov chain Monte Carlo, with the Monte Carlo
integration over ancestral speciation times evaluated at a low
accuracy level (controled by <code>delta0</code>).  The program then calculates the (relative) posterior probabilities of these candidate
labeled histories, with the Monte Carlo integration evaluated at a
higher accuracy level (controled by <code>delta1</code>).  The Markov chain moves with probability <code>beta</code> to another labeled
history of the same tree topology, or to a labeled history of a
different tree topology through a nearest neighbor interchange.  <code>hierarch </code>controls whether an empirical Bayes analysis or
a hierarchical Bayes analysis is to be performed.  <code>birth</code>, <code>death</code>, and <code>sample</code> are paramters of the prior
distribution specified by the birth-death process with species sampling. </pre>

<h1><a href="#toc">Interpreting Outputs</a></h1>

<h2><a name="mlb">Output file for <code>baseml</code></a></h2>

<pre>This file is self-explanatory and part of an example output file (from
<code>baseml</code>) is listed below. Descriptive
statistics are always listed.  The observed <i>site patterns </i>and
their frequencies are listed, together with the proportions of
<i>constant patterns</i>.  Nucleotide frequencies for each species
(and for each gene in case of multiple gene data) are counted and
listed.  <i>l</i><sub>max</sub> = 
ln(<i>L</i><sub>max</sub>) is the upper limit of the log likelihood
and may be compared with the likelihood for the best (or true) tree
under the substitution model to test the model's goodness of
fit to data (Goldman, 1993a). </pre>

<dir>
    <li><pre>
baseml  brown.nuc  HKY85  (4 genes, different rates) 
human 
chimapnzee 
gorilla 
orangutan 
gibbon  

ns = 5   ls = 895 
ngene = 4:  lengths: 233  232  232  198 
# of site patterns = 153 
Average T:0.25318  C:0.32894  A:0.31196  G:0.10592 
# constant sites: 613 ( 68.49%)  

TREE # 1: (12345)  
lnL(ntime: 5 np: 9): -2587.506845    +0.000000 
  6..1    6..2    6..3    6..4    6..5  
0.03882 0.05012 0.06074 0.14634 0.18633 0.33989 3.40714 0.58077 11.46578  


TREE # 2: ((123)45) 
lnL(ntime: 6 np: 10): -2550.884230   +36.622616 
  6..7    7..1    7..2    7..3    6..4    6..5  
0.05586 0.03290 0.04135 0.05501 0.08516 0.12082 0.39024 3.93286 0.64946 11.72917  

TREE # 3: (((12)3)45) 
lnL(ntime: 7 np: 11): -2542.948041   +44.558804 
  6..7    7..8    8..1    8..2    7..3    6..4    6..5  
0.05081 0.01323 0.03219 0.04059 0.04502 0.08774 0.12418 0.37752 3.83740 0.61889 12.05461 
</pre>
    </li>
</dir>

<pre>Pairwise distances are calculated based on the same model specified
for the likelihood analysis, with either a single rate for all sites
or (continuous) gamma rates for sites assumed; in the latter case the
initial value for the <font size="2" face="Symbol">a</font> parameter is
used in the calculation.  If the specified model is HKY85 or REV, the
distances are calculated using the model of Tamura and Nei (1993).
The transition/transversion rate ratio (<font face="Symbol">k</font>)
for the K80, F84 models are also estimated for each pairwise
comparison, and with the model of Tamura and Nei (1993) which has two
such ratios, the average is calculated. </pre>

<p>For <code>runmode = 0 </code>(user tree), the programs fit
branch lengths by the (ordinary) least squares method for each
tree topology based on pairwise distance estimates. These are
then used as initial values for iterative likelihood estimation;
initial values chosen in this way are actually quite poor because
the two methods normally produce quite different branch length
estimates, especially for &quot;bad&quot; trees (Yang 1994b). For
each tree, the log likelihood is listed, together with the
likelihood difference between the current tree and the first tree
(usually a star-like tree). This likelihood difference is listed
for easy comparison but not for evaluating the reliability of the
bifurcating tree. The listed value for <code>ntime</code> in the
bracket is the number of branches when the clock is not assumed
or the number of interior nodes when the clock is assumed, while <code>np</code>
is the number of all parameters being estimated. Theoretically, a
bifurcating tree should not be poorer (have lower likelihood
value) than the star-like tree, but with my programs, the
bifurcating tree may look slightly worse. The reason is that
parameters are bounded during the iteration; for example, branch
lengths may be restricted to be, say, &gt; 0.0001. If this
happens, one or more interior-branch lengths should be very close
to zero, and the bifurcating tree should be taken as converging
to the multifurcating tree. </p>

<p>For the tree-search modes (<code>runmode</code> = 1 or 2), two
values are listed for the likelihood: the first is the log
likelihood of the current tree and the second is the likelihood
increment relative to the best tree of the previous search stage.
</p>

<p>Below the line of likelihood values are the maximum likelihood
estimates of parameters. These include branch lengths in an
unrooted tree or divergence times in a rooted tree (both called
time parameters), and other parameters which are common to tree
topologies. If you choose <code>verbose = 1</code>, the program
will list parameter estimates in more detail so that you know
which is which. Parameters in the programs are arranged in a
fixed order in the output (and in the iterative algorithm): </p>

<dir>
    <li>[1] <i>t</i>: branch lengths (<code>clock</code> = 0) or
        divergence times (<code>clock</code> = 1);<br>
        [2] <i>c</i><sub><i>j</i></sub>: rate parameters for
        genes (<i>g</i> - 1 parameters for <i>g</i> genes; <i>c</i><sub>1</sub>
        = 1); <br>
        [3] rate ratio parameters: <font size="2" face="Symbol">k</font>
        in K80, F84, HKY85, <font size="2" face="Symbol">k</font><sub>1</sub>
        and <font size="2" face="Symbol">k</font><sub>2</sub> in
        TN93, or <i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>, <i>e </i>in
        REV (TN93 and REV for <code>baseml</code> only); <br>
        [4] frequency parameters <font face="Symbol">p</font><sub>T</sub>,
        <font face="Symbol">p</font><sub>C</sub>, <font
        face="Symbol">p</font><sub>A</sub> (for <code>nhomo</code>
        &gt; 0 in <code>baseml</code> only); <br>
        [5] <font size="2" face="Symbol"><i>a</i></font> of the
        (discrete-) gamma distribution; <br>
        [6] <font size="2" face="Symbol">r</font> of the
        auto-discrete-gamma model (unavailable for <code>basemlg</code>);
    </li>
</dir>

<pre>The above list does not include parameters that do not exist in the
model or are not estimated by iteration.  For example, when JC69 is
assumed or when K80 is assumed with <code>fix_kappa</code> = 1, <font
face="Symbol">k</font> will not be on the above list in either model
as it is not a parameter to be estimated from the data.  With data of
multiple genes (option G in the data file and <code>Mgene</code> in
the control file), the above order of parameters is maintained.  For
example, if different transition/transversion rate parameters and
gamma distributions are assumed for different genes in the TN93 model,
the order of the parameters will be <font face="Symbol">k</font><sub>1</sub> and <font
face="Symbol">k</font><sub>2</sub> for
the first gene, <font face="Symbol">k</font><sub>1</sub> and <font
face="Symbol">k</font><sub>2</sub> for the second gene, and so on, and
<font face="Symbol">a</font> for the first gene, followed by <font
face="Symbol">a</font> for the second gene, and so forth. </pre>

<p>Without the assumption of a molecular clock, the model will
involve as many time parameters as the number of branchs;
estimates of these are listed right below the branches. When a
clock is assumed, the model will involve as many time parameters
as the number of interior nodes, which are the times before
present of divergence at the nodes. For example, the rooted tree
((13)24), represented with its branches as </p>

<dir>
    <li>5 .. 6, 6 .. 1, 6 .. 3, 5 .. 2, 5 .. 4 </li>
</dir>

<pre>has two interior nodes (5 and 6) and has two time parameters; these
are arranged in the increasing order of the node numbers (<i>i.e.</i>,
that for node 5 comes first and that for node 6 second). </pre>

<p>In the example shown above, the HKY85 model was fitted to the
data of Brown <i>et al</i>. (1982). The sites are grouped into
four classes (4 genes). Tree #3, represented as (((12)3)45), is
(((human, chimpanzee), gorilla), orangutan, gibbon), and
estimates of the common parameters from this tree are <i>c</i><sub>2</sub>
= 0.37752, <i>c</i><sub>3</sub> = 3.83740, <i>c</i><sub>4</sub> =
0.61889, and <font size="2" face="Symbol">k</font> = 12.05461. </p>

<p>With <code>getSE</code> = 1, the S.E.s are calculated as the
square roots of the large sample variances and listed exactly
below the parameter estimates. Zeros on this line mean errors,
either caused by divergence of the algorithm or zero branch
lengths. The S.E.ís of the common parameters measure the
reliability of the estimates. For example, (<font size="2"
face="Symbol"><i>k -</i></font> 1)/SE(<font size="2"
face="Symbol">k</font>), when <font size="2" face="Symbol">k</font>
is estimated under K80, can be compared with a normal
distribution to see whether there is real difference between K80
and JC69. The test can be more reliably performed by comparing
the log-likelihood values under the two models, using the
likelihood ratio test. It has to be stressed that the S.E.ís of
the estimated branch lengths should not be misinterpreted as an
evaluation of the reliability of the estimated tree topology (<i>e.g.</i>,
Yang, 1994b, Goldman and Yang, 1994). </p>

<h2><a name="mlc">Output file for <code>codeml</code> (<code>codonml</code>
and <code>aaml</code>) </a></h2>

<pre><b>For </b><code><b>codonml</b></code><b> (</b><code><b>codeml</b></code><b> with </b><code><b>seqtype = 1</b></code><b>).
</b>

The codon frequencies in each sequence are counted and listed in a
genetic code table, together with their sums across species.  Each
table contains up to six species, and is about the width of a page
when the 8-point courier font is used.  For data of multiple genes
(option G in the sequence file), codon frequencies in each gene
(summed over species) are also listed.  The base distributions at the
three codon positions are also listed.  The method of Nei and Gojobori
(1986) is used to calculate the number of synonymous substitutions per
synonymous site (<i>d</i><sub>S</sub>) and the number of nonsynonymous
substitutions per nonsynonymous site (<i>d</i><sub>N)</sub> and their
ratio (<i>d</i><sub>N</sub>/<i>d</i><sub>S</sub>).  These are used to
construct initial estimates of branch lengths for the likelihood
analysis.  Note that the estimates of these quantities for the
<font size="2" face="Symbol">a</font>- and <font size="2"
face="Symbol">b</font>-globin genes shown in Table 2 of Goldman
and Yang (1994), calculated using the MEGA package (Kumar <i>et
al.</i>, 1993), are not accurate. </pre>

<p>Parameters in the <code>codonml</code> program are arranged in
the following order </p>

<dir>
    <li>[1] <i>t</i>: branch lengths (clock = 0) or divergence
        times (clock = 1); <br>
        [2] <i>c</i><sub><i>j</i></sub>: rate parameters for
        genes (<i>c</i><sub>2</sub>, <i>c</i><sub>3</sub>, ...,
        with <i>c</i><sub>1</sub> = 1); <br>
        [3] <font face="Symbol">k</font> and <font face="Symbol">w</font>
        in the rate matrix of equation 9; <br>
        [4] <font face="Symbol">a</font> of the discrete-gamma
        model for rates at codon sites; <br>
        [5] <font face="Symbol">r</font> of the
        auto-discrete-gamma model for rates at codon sites. <br>
        </li>
</dir>

<pre>The number of rate parameters (item [3]) is given as
<code>nrate</code> at the beginning of the file.  The
<i>d</i><sub>N</sub>/<i>d</i><sub>S</sub> ratio is calculated from the
codon-based model following Goldman and Yang (1994), and is listed
below parameter estimates. </pre>

<p><b>For </b><code><b>aaml</b></code><b> (</b><code><b>codeml</b></code><b>
with </b><code><b>seqtype</b></code><b> = 2). </b>The file <code>mlc</code>
produced for <code>aaml</code> is self-explanatory and very
similar to the result files for the nucleotide- and codon-based
models. The models for amino acid substitution based on the PAM
matrices of Dayhoff <i>et al. </i>(1978) or Jones <i>et al</i>.
(1992) do not involve any parameters in the substitution rate
matrix (nrate = 0). </p>

<h2><a name="rst">Secondary result files <code>rst</code> and <code>rates</code></a></h2>

<p>When <code>RateAncestor </code>= 1, the programs <code>baseml</code>
and <code>aaml </code>generate results for ancestral
reconstruction in the file <code>rst</code>. Calculated
substitution rates for sites under models of variable rates for
sites are now in the file <code>rates</code> and not in <code>rst</code>
as in previous versions. Under codon-based models that allow for
variable dN/dS ratios among sites (<code>NSsites</code> = 1 or
2), the most likely dN/dS categories for sites are in <code>rst</code>.
</p>

<p>Some of those analysis necessarily produces identical results
for sites with the same data. Thus sometimes the results may be
listed once for each &quot;site pattern&quot; and not for each
site, to save space. Then a table is included in the files to map
sites to patterns. </p>

<h1><a href="#toc">Models and Methods </a></h1>

<h2><a name="Q4">Substitution models for nucleotides (<code>baseml</code>)</a></h2>

<pre>Markov process models of nucleotide substitution implemented in PAML include JC69 (Jukes and Cantor, 1969), K80 (Kimura,
1980), F81 (Felsenstein, 1981), F84 (Felsenstein, DNAML program since
1984, PHYLIP Version 2.6), HKY85 (Hasegawa <i>et al.</i>, 1985),
Tamura and Nei (1993), and REV (Yang, 1994a).  The rate matrices of
these models are given below </pre>

<dir>
    <li><img src="Q4x4.gif" width="529" height="883"> </li>
</dir>

<p>The element <i>q</i><sub><i>ij</i></sub> (<i>i </i>! = <i>j</i>)
represents the rate of substitution from nucleotide <i>i </i>to <i>j</i>,
with the nucleotides ordered <i>T</i>, <i>C</i>, <i>A</i>, <i>G</i>.
The diagonals <i>q</i><sub><i>ii</i></sub> are specified by the
mathematical requirement that row sums of <i>Q</i><b> </b>are
zero. The transition probability matrix over time <i>t</i> is
then <i>P</i>(<i>t</i>) = {<i>p</i><sub><i>ij</i></sub>(<i>t</i>)}
= exp(<i>Qt</i>), where <i>p</i><sub><i>ij</i></sub>(<i>t</i>) is
the probability that nucleotide <i>i</i> will become nucleotide <i>j</i>
after time <i>t</i>. The nature of the problem does not permit
separation of rate (<i>Q</i>) and time (<i>t</i>), and <i>Q</i><b>
</b>is multiplied by a constant so that the average rate of
substitution is 1 when the process is in equilibrium. This
scaling means that time <i>t</i>, or the branch length in a tree,
is measured by the expected number of nucleotide substitutions
per site. <i>Q</i><b> </b>thus represents the <i>pattern of
substitution</i>, while the amount of evolution is reflected in
time or the branch length. The <i>frequency parameters </i><font
face="Symbol">p</font><sub>T</sub>, <font face="Symbol">p</font><sub>C</sub>,
<font face="Symbol">p</font><sub>A</sub>, <font face="Symbol">p</font><sub>G</sub>
(with sum to be 1) give the equilibrium distribution of the
process for the F81, F84, HKY85, TN93 and REV models; the
equalibrium distribution under the JC69 and K80 models has equal
frequencies (1/4) for the four nucleotides, which is rarely true
for real data. Parameters <i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>,
<i>e </i>in REV, <font face="Symbol">k</font> in F84 or HKY85,
and <font face="Symbol">k</font><sub>1</sub> and <font
face="Symbol">k</font><sub>2</sub> in TN93 may be termed <i>rate
ratio parameters</i>. So the JC69, K80, F81, F84, HKY85, TN93 and
REV models contain 0, 1, 0, 1, 1, 2, 5 rate ratio parameters
respectively, and 0, 0, 3, 3, 3, 3, 3 frequency parameters
respectively. Normally the frequency parameters are estimated
using the averages of the observed frequencies, which should be
very close to the true maximum likelihood estimates if the
assumptions of homogeneity and stationarity are not too wrong. </p>

<p>Parameter <font face="Symbol">k</font> in the K80 and HKY85
models is equivalent to <font face="Symbol">a</font>/<font
face="Symbol">b</font> in the notation of Kimura (1980) and
Hasegawa <i>et al.</i> (1985), who used <font face="Symbol">a</font>
and <font face="Symbol">b</font> to refer to rates of
transitional and transversional substitutions, repectively.
Tamura and Nei (1993) used <font face="Symbol">k</font><sub>2</sub>,
<font face="Symbol">a</font><sub>1</sub>, and <font face="Symbol"><i>b</i></font>
instead of <font face="Symbol">k</font><sub>1</sub> and <font
face="Symbol">k</font><sub>2</sub>. The present notation is more
convenient in a maximum likelihood analysis as the ratio is
assumed to be constant for different branches of the tree. F84 is
the model implemented in J. Felsenstein's DNAML program. The rate
matrix for this model was given by Hasegawa and Kishino (1989),
Kishino and Hasegawa (1989), Yang (1994b, 1994c) and Tateno <i>et
al</i>. (1994). Thorne <i>et al.</i> (1992) described the
transition probability matrix, and Yang (1994c) and Tateno <i>et
al.</i> (1994) derived formulae for estimating sequence distances
under the model. REV is the general reversible process model
(Yang, 1994a; see also Tavare, 1986; Zharkikh, 1994) and is used
in <code>baseml</code> only. It seems sufficiently general to
enable accurate estimation of the substitution pattern from real
data. See Gillespie (1986), Tavare (1986), Rodriguez <i>et al</i>.
(1990), Yang (1994a), and Zharkikh (1994) for reviews of
substitution models. </p>

<p>Note that there are several different definitions of the
&quot;transition/transversion rate ratio&quot;. My programs
estimate the parameters specified in the above formulas. To make
estimates comparable among models, one can calculate the
transition/transversion rate ratio averaged by base frequencies: </p>

<dir>
    <li>(8) <i>R</i> = (<font face="Symbol">p</font><sub><i>T</i></sub><i>q</i><sub><i>TC</i></sub>+
        <font face="Symbol">p</font><sub><i>C</i></sub><i>q</i><sub><i>CT</i></sub>+<font
        face="Symbol">p</font><sub><i>A</i></sub><i>q</i><sub><i>AG</i></sub>+<font
        face="Symbol">p</font><sub><i>G</i></sub><i>q</i><sub><i>GA</i></sub>)
        / (<font face="Symbol">p</font><sub><i>T</i></sub><i>q</i><sub><i>TA
        </i></sub>+ <font face="Symbol">p</font><sub><i>T</i></sub><i>q</i><sub><i>TG</i></sub>
        + <font face="Symbol">p</font><sub><i>C</i></sub><i>q</i><sub><i>CA</i></sub>
        + <font face="Symbol">p</font><sub><i>C</i></sub><i>q</i><sub><i>CG</i></sub>
        + <font face="Symbol">p</font><sub><i>A</i></sub><i>q</i><sub><i>AT</i></sub>
        + <font face="Symbol">p</font><sub><i>A</i></sub><i>q</i><sub><i>AC</i></sub>
        + <font face="Symbol">p</font><sub><i>G</i></sub><i>q</i><sub><i>GT</i></sub>
        + <font face="Symbol">p</font><sub><i>G</i></sub><i>q</i><sub><i>GC</i></sub>).
    </li>
</dir>

<h2><a name="Qcodon">Substitution models for codons (<code>codonml:</code>
<code>codeml.c</code> with <code>seqtype</code> = 1) </a></h2>

<pre>Compared with models for nucleotide substitution, models
for codon substitution are not well developed.  The model of Goldman and Yang
(1994) specifies the probability of
substitution between the sense codons, by using the matrix of amino
acid distances of Grantham (1974).  The model does not seem to fit real
data well, however, and the user is advised to use the following
simpler version, which is equivalent to use equal distances for any
pair of amino acids.  The substitution rate from codon <i>i</i> to
<i>j</i> is given as </pre>

<dir>
    <li><img src="Qcodon.gif" width="457" height="133"> </li>
</dir>

<p>The equilibrium frequency of codon <i>j</i> (<font
face="Symbol">p</font> <sub><i>j</i></sub>) can be considered a
free parameter, but can also be calculated from the nucleotide
frequencies at the three codon positions (option variable <code>CodonFreq</code>).
Under this model, the relationship holds that <font size="2"
face="Symbol">w</font> = <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub>,
the ratio of nonsynonymous/synonymous substitution rates. This
model is also used to construct more sophisticated models that
allow the <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub> ratio (<font
face="Symbol">w</font>) to vary among branches in the phylogeny
or among codon sites in the sequence. </p>

<p>The number of synonymous substitutions per synonymous site (<i>d</i><sub>S</sub>)
and the number of nonsynonymous substitutions per nonsynonymous
site (<i>d</i><sub>N</sub>) are calculated according to the
method of Goldman and Yang (1994). The program <code>codonml</code>
with option <code>runmode</code> = -2 calculates these statistics
for all pairwise comparisons. </p>

<h2><a name="Q20">Substitution models for amino acids (<code>aaml:
codeml.c</code> with <code>seqtype = 2</code>) </a></h2>

<pre>Empirical models based on the Dayhoff substitution matrix (<code>model
 = 2</code>) or its updated version of Jones <i>et al</i>. (1992) are
constructed using the same strategy.  The transition probability
matrix over a very short time period such as one PAM, <i>i.e.</i>,
<i>P</i>(0.01), is used to approximate the matrix of instantaneous
rates (<i>Q</i>).  The empirical matrices of Dayhoff <i>et
al</i>. (1978) and Jones <i>et al</i>. (1992) were made to satisfy the
reversibility condition, that is, </pre>

<dir>
    <li><font face="Symbol">p</font><sub><i>i</i></sub><i>q</i><sub><i>ij</i></sub>
        = <font face="Symbol">p</font><sub><i>j</i></sub><i>q</i><sub><i>ji</i></sub></li>
</dir>

<pre>for any <i>i</i> and <i>j</i>, so that my implementations may be
slightly different from that of Kishino <i>et al.</i> (1990).  These
models assume a fixed pattern of amino acid substitution, and cannot
identify possible differences in the evolutionary dynamics of
different proteins. The package also include two similar empirical
models for mitochondrial proteins.  The first is given by the file
<code>mtREV24.dat</code> and is the mtREV24 model of Adachi and
Hasegawa (1996a, b) estimated from a diverse range of species
including mammals, chicken, frog, fish, and lamprey.  The matrix was
estimated by maximum likelihood from real data.  The second is given
by the file mtmam.dat and is estimated from 20 mammalian species using
maximum likelihood under the REV model with variable rates among sites
(Yang et al. 1998).  You can check those files for more details, or if
you want to supply your own empirical matrix. </pre>

<p>&quot;Mechanistic&quot; models of amino acid substitution
would require consideration of both the mutational distance
between the amino acids as determined by the locations of their
encoding codons in the genetic code table, and the effects that
the potential change may have on the structure and function of
the protein, which may be related to the physical, chemical and
structural differences between amino acids. It seems natural that
such a model should be formulated at the level of codons. The
program <code>aaml</code> implements a few such models, specified
by the variable <code>aaDist</code>. </p>

<h2><a name="rates">Variable substitution rates across sites</a></h2>

<pre>Recent work on this topic was reviewed by Yang (1996b).  Two
approaches have been taken to account for variable rates among sites
in models used in phylogenetic analysis.  The first is to use several
categories of rates.  Such models are implemented in
<code>baseml</code> only (the control variable <code>nparK</code>).
The difficulty is that there will be too many parameters if more than
two categories are assumed.  The second approach is to use a
continuous distribution to approximate variable rates at sites, and
the most commonly used continuous distribution is the gamma.  This
distribution has a shape parameter <font face="Symbol">a</font> and a scale parameter <font
face="Symbol">b</font> with mean <font face="Symbol">a</font>/<font
face="Symbol">b</font> and variance <font face="Symbol">a</font>/<font
face="Symbol">b</font><sup>2</sup>.  We set <font face="Symbol">b</font> = <font
face="Symbol">a</font> so that the mean of the distribution is 1 (with
variance 1/<font face="Symbol">a</font>).  The
single parameter <font face="Symbol">a</font> is
then inversely related to the extent of rate variation at sites.
Maximum llikelihood estimation under the gamma model of rates for
sites (implemented in <code>basemlg </code>for nucleotide
sequences only) is very slow.  A more practical approach is the
discrete-gamma model suggested by Yang (1994c) and used in
<code>baseml</code>, <code>codonml</code>, and
<code>aaml</code> to approximate the rate variation among
nucleotide, codon and amino acid sites.  Several categories, chosen
such that each category has equal probability of occurrence, are used
to approximate the gamma distribution, with the mean of the category
used to represent all rates in the category (Yang, 1994c).  So the
discrete-gamma model, like the continuous gamma, involves a single
parameter <font face="Symbol">a</font>.  Four
such categories (<code>ncatG</code> = 4) seems to be enough for a
good approximation (Yang, 1994c).  However, if the <font
face="Symbol">a</font> estimate is very small (say,
&lt; 0.2) or if the purpose of the analysis is to estimate the <font
face="Symbol">a</font> parameter of the (continuous) gamma for use
in estimating pairwise distances, it may be better to use more
categories (say 8).  The auto-discrete-gamma model was initiated by
the observation of the existence of <i>variable </i>and <i>conserved
</i>regions in a gene, from which we expect substitution rates at
neighboring sites to be positively correlated.  The model, described
by Yang (1995), has an extra parameter <font face="Symbol">r</font> that measures the correlation of rates at two
adjacent sites.  The model is implemented in
<code>baseml</code>, <code>codonml</code> and <code>aaml</code>. </pre>

<p>Substitution rates for sites are calculated using the
conditional mean of the rates given the data (Yang and Wang,
1995; Yang, 1995). The calculated rates for sites, after some
smoothing, can be plotted along the sequence to help identify
variable and conserved regions. </p>

<h2><a name="mgene">Models for combined analyses of heterogeneous
data (multiple genes or codon positions)</a></h2>

<p>Several models are described by Yang (1996a) and implemented
in<br>
programs <code>baseml</code> and <code>codeml</code>(<code>codonml</code>
and <code>aaml</code>) for analyzing heterogeneous data sets
(such as those of multiple genes or<br>
different codon positions). The implementation and description
below refer to the case of multiple genes, but in the case of
nucleotide-based models (<code>baseml</code>), the method can be
used to analyze data of different codon positions. These models
account for different aspects of heterogeneity among the
different data sets and are useful for testing hypotheses
concerning the similarities and differences in the evolutionary
process of different data sets. </p>

<p>The simplest model which assumes complete homogeneity among
genes can be fitted by concatenating different genes into one
sequence without using the option G (and by specifying <code>Mgene</code>
= 0 in the control file). The most general model is equavilent to
a separate analysis. This can be done by fitting the same model
to each data set (each gene), but can also be done by specifying <code>Mgene</code>
= 1 with the option G in the combined data file. The sum of the
log-likelihood values over different genes is then the log
likelihood of the most general model considered here. Models
accounting for some aspects of the heterogeneity of multiple
genes are fitted by specifying <code>Mgene</code> in combination
with the option G in the sequence data file. <code>Mgene</code> =
0 means a model that asumes different substitution rates but the
same pattern of nucleotide substitution for different genes. <code>Mgene</code>
= 2 means different frequency parameters for different genes but
the same rate ratio parameters (<font face="Symbol">k</font> in
the K80, F84, HKY85 models or the rate parameters in the TN93 and
REV models). <code>Mgene</code> = 3 means different rate ratio
parameters and the same frequency parameters. <code>Mgene</code>
= 4 means both different rate ratio parameters and different
frequency parameters for different genes. Parameters and
assumptions made in these models are summarized in the following
table, with the HKY85 model used as an example. When substitution
rates are assumed to vary from site to site, the control variable
Malpha specifies whether one gamma distribution will be applied
across all sites (<code>Malpha</code> = 0) or a different gamma
distribution is used for each gene (or codon position). </p>

<table border="1" cellpadding="7" width="619">
    <tr>
        <td valign="top" width="22%"><p align="center">Sequence
        file </p>
        </td>
        <td valign="top" width="17%"><p align="center">Control
        file</p>
        </td>
        <td valign="top" width="61%">Parameters across genes</td>
    </tr>
    <tr>
        <td valign="top" width="22%"><p align="center">Without
        option G</p>
        </td>
        <td valign="top" width="17%"><p align="center">Mgene = 0</p>
        </td>
        <td valign="top" width="61%">everything equal</td>
    </tr>
    <tr>
        <td valign="top" width="22%"><p align="center">Option G</p>
        </td>
        <td valign="top" width="17%"><p align="center">Mgene = 0</p>
        </td>
        <td valign="top" width="61%">the same <font face="Symbol">k</font>
        and <font face="Symbol">p</font>, but different <i>c</i>s
        (proportional branch lengths)</td>
    </tr>
    <tr>
        <td valign="top" width="22%"><p align="center">Option G</p>
        </td>
        <td valign="top" width="17%"><p align="center">Mgene = 2</p>
        </td>
        <td valign="top" width="61%">the same <font face="Symbol">k</font>
        , but different <font face="Symbol">p</font> s and <i>c</i>s</td>
    </tr>
    <tr>
        <td valign="top" width="22%"><p align="center">Option G</p>
        </td>
        <td valign="top" width="17%"><p align="center">Mgene = 3</p>
        </td>
        <td valign="top" width="61%">the same <font face="Symbol">p</font>
        , but different <font face="Symbol">k</font>s and <i>c</i>s</td>
    </tr>
    <tr>
        <td valign="top" width="22%"><p align="center">Option G</p>
        </td>
        <td valign="top" width="17%"><p align="center">Mgene = 4</p>
        </td>
        <td valign="top" width="61%">different <font
        face="Symbol">k</font> , <font face="Symbol">p</font> s,
        and <i>c</i>s</td>
    </tr>
    <tr>
        <td valign="top" width="22%"><p align="center">Option G</p>
        </td>
        <td valign="top" width="17%"><p align="center">Mgene = 1</p>
        </td>
        <td valign="top" width="61%">different <font
        face="Symbol">k</font> , <font face="Symbol">p</font> s,
        and different (unproportional) branch lengths</td>
    </tr>
</table>

<p>The different <i>c</i>s for different genes mean that branch
lengths estimated for different genes are proportional.
Parameters <font face="Symbol">p</font> represent the equilibrium
nucleotide frequencies, which are estimated using the observed
frequencies (<code>nhomo</code> = 0). The transition/transversion
rate ratio <font face="Symbol">k</font> in HKY85 can be replaced
by the two or five rate ratio parameters under the TN93 or REV
models, respectively. The likelihood ratio test can be used to
compare these models, using an approach called the analysis of
deviance, which is very similar to the more familiar analysis of
variance. </p>

<h2><a name="clock">The molecular clock</a></h2>

<pre>The assumption of a molecular clock means that substitution rates are
constant among lineages.  It is specified as <code>clock</code>
 = 1 for <code>baseml</code>, <code>codonml</code>, and
<code>aaml</code>, and is not available for <code>basemlg</code>.
With this assumption, the trees are rooted and there are as many time
parameters as the number of interior nodes in the tree (<i>n</i> - 2
for a tree of <i>n</i> species).  Without the clock assumption
(<code>clock</code> = 0), the number of time parameters is equal to
the number of branches (2<i>n</i> -3 for a tree of <i>n</i> species). </pre>

<h2><a name="nhomo">The nonhomogeneous models (<code>nhomo</code>
for <code>baseml</code>)</a></h2>

<pre>The option <code>nhomo</code> for <code>baseml</code> concerns the
frequency parameters in the F81, F84, HKY85, TN93, or REV models.  The
option <code>nhomo</code> = 1 fits a homogeneous model, but estimates
the frequency parameters by maximum likelihood iteration.  Normally
(<code>nhomo</code> = 0) these are estimated by the averages of the
observed frequencies.  In both cases, you should count 3 free
parameters for the base frequencies.  The options <code>nhomo</code> =
3 or 4, in combination with F84 or HKY85, fit nonhomogeneous models of
Yang and Roberts (1995).  Substitutions are assumed to follow the
pattern of F84 or HKY85, but with different frequency parameters
assigned for different branches in the tree, to allow for unequal base
frequencies in different sequences.  The position of the root then
makes a difference to the likelihood, and rooted trees are used.
Because of the parameter richness, the model may only be used with
small data sets when base frequencies are drastically different in
different sequences.  Choose <code>fix_kappa</code> = 1, which means
one common <font face="Symbol">k</font> is assumed for all
branches.  The option <code>nhomo</code> = 4 assigns one set of
frequency parameters for each node, which are the parameters for the
rate matrix along the branch leading to the node or are the initial
distribution if the node is the root of the tree.  In the output,
estimates of the frequency parameters are shown in the order of nodes
<i>n</i> + 1, <i>n</i> + 2, ...., where <i>n</i> is the number of
sequences. </pre>

<h2><a name="ancestral">Reconstruction of ancestral sequences</a></h2>

<pre>Nucleotides or amino acids of extinct ancestors can be reconstructed
using information of the present-day sequences.  Parsimony
reconstructs ancestral character states by the criterion that the
number of changes along the tree at the site is minimized.  Algorithms
based on this criterion were developed by Fitch (1971) and Hartigan
(1973), and are implemented in the program <code>pamp</code>.
The likelihood approach uses branch lengths and the substitution
pattern for ancestral reconstruction.  It was developed by Yang <i>et
al.</i> (1995) and is implemented in <code>baseml</code> for
nucleotide sequences and in <code>aaml</code>
(<code>codeml.c</code> with <code>seqtype</code> = 2) for
amino acid sequences.  Results are collected in the file
<code>rst</code>. </pre>

<p><b>Marginal reconstruction</b>: This approach assigns a
nucleotide or amino acid to an interior node at a site according
to its posterior probabilities (eq. 4 in Yang et al. 1995). The
algorithm implemented in paml works under both the model of a
constant rate for sites and the gamma-rates model. If <code>verbose</code>
= 1, the output will include the full probability distribution at
each node at each site. </p>

<p><b>Joint reconstruction</b>: This approach considers the
assignment of a set of characters to all interior nodes at a site
as a reconstruction (eq. 2 in Yang et al. 1995), and the
implementation in paml works under the model of a constant rate
for sites only. (It should work under models for multiple genes
or data partitions, but I have not tested this carefully.) The
program makes a guess at the likely character states at the
interior nodes of the tree, and then uses those to generate
possible reconstructions to be evaluated. The current rules are:
(1) with fewer than 15 interior nodes in the tree for nucleotide
sequences or 7 for amino acid sequences, the program evaluates
all reconstructions that can be generated by assigning to each
interior node all nucleotides (or amino acids) that are observed
at the site in any of the sequences; (2) for even larger trees,
the program uses the parsimony algorithm to generate the
equivocal character states at each interior node, and then
evaluates reconstructions that can be generated from those
equivocal states. The strategy may miss important reconstructions
when the data contain more than several species; an indicator of
the occurrence of this problem is that the sum of probabilities
for the listed reconstructions at a site is not close to one.
Note that the problem is possible failure to evaluate some
reconstructions with high probabilities, but the probabilities
for the evaluated reconstructions are correct. An option
(RateAncestor = 2) allows the user to specify the site and
reconstruction to be evaluated. </p>

<p>The marginal and joint approaches are expected to produce very
similar results. Since the marginal reconstruction is always
reliable and works with models of variable rates among sites, it
is recommended for data analysis. </p>

<h2><a name="bayes">Bayesian estimation of phylogenetic trees</a></h2>

<pre>The program <code>mcmctree</code> performs Bayesian estimation of
phylogenies (Rannala and Yang, 1996; Yang and Rannala, 1997).  The
birth-death process with species sampling is used to specify the prior
distribution of phylogenies (&quot;labeled histories&quot;, which are
rooted tree topologies with the interior nodes ordered according their
associated speciaiton times), and the posterior probabilities of the
labeled histories are compared to select the maximum posterior
probability tree.  The program implementing the method of Rannala and
Yang (1996) is not distributed as the algorithm involves extensive
computation.  Instead, <code>mcmctree</code> implements a
refined method (Yang and Rannala 1997), which uses Markov chain Monte
Carlo to select candidate labeled histories, and Monte Carlo
integration to integrate over the distribution of the ancestral
speciation times. </pre>

<h2><a name="simulate">Simulating sequence data sets</a></h2>

<pre>The program <code>evolver</code> has options for simulating data sets
under nucleotide, codon, or amino acid substitution models.  The tree
and branch lengths can either be specified or generated from a model
of cladogenesis, the birth-death process with species sampling (Yang
and Rannala, 1997).  Multiple simulated data sets are put in one file
in either <code>PAML</code> or <code>PAUP*</code> format.  If you
choose the PAUP* format, the program will look for files with the
following names: <code>paupstart</code> (which the program copies to
the start of the data file), <code>paupblock</code> (which the program
copies to the end of each simulated data set), and
<code>paupend</code> (which the program incoporate at the end of the
file.  Parameters for simulation are specied in three files:
<code>MCbase.dat</code>, <code>MCcodon.dat</code>, and
<code>MCaa.dat</code> for simulating nucleotide, codon, and amino acid
sequences, respectively.  Run the default options first and also look
at those files as well as the screen output. </pre>

<h2><a name="treesearch">Tree search algorithms </a></h2>

<pre>One heuristic tree search algorithm implemented in
<code>baseml</code>, <code>codonml</code> and <code>aaml</code> is a
divisive algorithm, called &quot;star-decomposition&quot; by Adachi and Hasegawa
(1996a).  The algorithm starts from either the star tree
(<code>runmode</code> = 2) or a multifurcation tree read from the tree
structure file (<code>runmode</code> = 1).  The algorithm joins two
taxa to achieve the greatest increase in log-likelihood over the
star-like tree.  This will reduce the number of OTUs by one.  The
process is repeated to reduce the number of OTUs by one at each stage,
until no multifurcation exists in the tree.  This algorithm works
either with or without the clock assumption. </pre>

<p>The stepwise addition algorithm is implemented with the option
<code>runmode</code> = 3. Options <code>runmode</code> = 4 or 5
are used for nearest neighbor interchanges , with the intial tree
determined with stepwise addition under the parsimony criterion (<code>runmode</code>
= 4) or read from the tree structure file (<code>runmode</code> =
5). The results are self-explanatory. My implementations of these
algorithms are crude, and a lot of work need to be done to make
them more efficient. These options work only when the clock is
not assumed (<code>runmode</code> = 0). </p>

<h1><a href="#toc">Technical details, problems and limitations</a><a></a></h1>

<h2><a name="variables">Adjustable variables in the source codes</a></h2>

<pre>This section is relevant only if you compile the source codes
yourself, and is not if you are running the precompiled executables
for Windows or MAC.  

The maximum values of certain variables are listed as constants in
uppercase at the beginning of the main programs
(<code>baseml.c</code>, <code>basemlg.c</code>,
<code>codeml.c</code>).  These values can be raised without increasing
the memory requirement by too much. </pre>

<pre>
	NS	maximum number of sequences (species)
	LSPNAME	maximum number of characters in a species name
	NGENE	maximum number of &quot;genes&quot; in data of multiple genes (option G)
	NCATG	maximum number of rate categories in the (auto-) discrete-gamma model (baseml.c, codeml.c)
</pre>

<pre>You may need to change the value of LSPNAME.  Other variables that may
be changed include the bounds for parameters, specified at the
beginning of the function <code>testx</code> or <code>SetxBound</code>
in the main programs (<code>baseml.c</code> and
<code>codeml.c</code>).  For example, these variables are defined in
the function <code>SetxBound</code> in <code>codeml.c</code>: 

   double tb[]={.0001,9}, rgeneb[]={0.1,99}, rateb[]={1e-4,999};
   double alphab[]={0.005,99}, rhob[]={0.01,0.99}, omegab[]={.001,99}; 
</pre>

<pre>The pairs of variables specify lower and upper bounds for variables
(tb for branch lengths, rgeneb for relative rates of genes used in
multiple gene analysis, alphab for the gamma shape parameter, rhob for
the correlation parameter in the auto-discrete-gamma model, and omegab
for the <i>d</i><sub>N</sub>/<i>d</i><sub>S</sub> ratio in codon based
analysis. </pre>

<h2><a name="problems">Known problems</a></h2>

<pre><b>Tree search. </b> The programs are not good for tree search.
Although a few options are available for heuristic tree search, they
do not work well except for very small data sets (say, with fewer than
10 species).  An option that may be feasible is to use other programs
or methods to collect a set of candidate trees into the tree structure
file, and then compare those trees using programs in the paml package
for a more-detailed comparison with models implemented in paml. </pre>

<h1><a href="#toc">Acknowledgments </a></h1>

<pre>I thank Nick Goldman, Adrian Friday, and Sudhir Kumar for many useful
comments on different versions of the program package. I thank Tianlin
Wang for the eigen routine used in the package.  I also thank a number
of users for reporting bugs and/or suggesting changes, especially Liz
Bailes, Thomas Buckley, Belinda Chang, Adrian Friday, Nicolas Galtier,
Nick Goldman, John Heulsenbeck, Sudhir Kumar, Robert D. Reed,
Fransisco Rodriguez-Trelles, John Heulsenbeck, John Mercer,
dubreuil@moulon.inra.fr, and Xuhua Xia.


</pre>

<h1><a href="#toc">References</a></h1>

<pre>Adachi, J., and M. Hasegawa.  1996a.  <i> MOLPHY Version 2.3: Programs for molecular phylogenetics based on maximum likelihood.</i>  Computer science monographs, 28:1-150.  Institute of Statistical Mathematics, Tokyo. </pre>

<p>Adachi, J., and M. Hasegawa. 1996b. Model of amino acid
substitution in proteins encoded by mitochondrial DNA. <i>Journal
of Molecular Evolution </i><b>42</b>:459-468.</p>

<p>Brown, W. M., E. M. Prager, A. Wang, and A. C. Wilson. 1982.
Mitochondrial DNA sequences of primates, tempo and mode of
evolution. <i>Journal of Molecular Evolution </i><b>18</b>:225-239.</p>

<p>Dayhoff, M. O., R. M. Schwartz, and B. C. Orcutt. 1978. A
model of evolutionary change in proteins. In <i>Atlas of Protein
Sequence and Structure</i>, Vol 5, Suppl. 3 (ed M. O. Dayhoff),
National Biomedical Research Foundation, Washington D.C., pp.
345-352.</p>

<p>Felsenstein, J. 1981. Evolutionary trees from DNA sequences: a
maximum likelihood approach. <i>Journal of Molecular Evolution </i><b>17</b>:368-376.</p>

<p>Felsenstein, J. 1985. Confidence limits on phylogenies: an
approach using the bootstrap. <i>Evolution </i><b>39</b>:783-791.</p>

<p>Felsenstein, J. 1993. <i>Phylogenetic Inference Package
(PHYLIP), Version 3.5</i>. University of Washington, Seattle.</p>

<p>Goldman, N. 1993a. Statistical tests of models of DNA
substitution. <i>Journal of Molecular Evolution </i><b>36</b>:182-198.</p>

<p>Goldman, N. 1993b. Simple diagnostic statistical tests of
models for DNA substitution. <i>Journal of Molecular Evolution </i><b>37</b>:650-661.</p>

<p>Goldman, N.<b>, </b>and Z. Yang. 1994. A codon-based model of
nucleotide substitution for protein-coding DNA sequences. <i>Molecular
Biology and Evolution </i><b>11</b>:725-736.</p>

<p>Grantham, R. 1974. Amino acid difference formula to help
explain protein evolution. <i>Science </i><b>185</b>:862-864.</p>

<p>Hartigan, J. A. 1973. Minimum evolution fits to a given tree. <i>Biometrics</i>
<b>29</b>: 53-65.</p>

<p>Hasegawa, M., and H. Kishino. 1989. Confidence limits on the
maximum likelihood estimation of the hominoid tree from
mitochondrial DNA sequences. <i>Evolution </i><b>43</b>:672-677.</p>

<p>Hasegawa, M., H. Kishino, and T. Yano. 1985. Dating the
human-ape splitting by a molecular clock of mitochondrial DNA. <i>Journal
of Molecular Evolution </i><b>22</b>:160-174.</p>

<p>Hayasaka, K., T. Gojobori, and S. Horai. 1988. Molecular
phylogeny and evolution of primate mitochondrial DNA. <i>Molecular
Biology and Evolution </i><b>5</b>:626-644.</p>

<p>Jones, D.T., W. R. Taylor, and J. M. Thornton. 1992. The rapid
generation of mutation data matrices from protein sequences. <i>Computer
Application in Biosciences </i><b>8</b>:275-282. </p>

<p>Kimura, M. 1980. A simple method for estimating evolutionary
rates of base substitutions through comparative studies of
nucleotide sequences. <i>Journal of Molecular Evolution </i><b>16</b>:111-120.</p>

<p>Kishino, H., and M. Hasegawa. 1989. Evaluation of maximum
likelihood estimate of the evolutionary tree topologies from DNA
sequence data, and the branching order in Hominoidea. <i>Journal
of Molecular Evolution </i><b>29</b>:170-179.</p>

<p>Kishino, H., T. Miyata, and M. Hasegawa. 1990. Maximum
likelihood inference of protein phylogeny and the origin of
chloroplasts. <i>Journal of Molecular Evolution </i><b>31</b>:151-160.</p>

<p>Kumar, S., K. Tamura, and M. Nei. 1993. <i>MEGA: Molecular
Evolutionary Genetics Analysis.</i> The Pennsylvania State
University, University Park, PA 16802.</p>

<p>Messier W. and C.-B. Stewart. 1997. Episodic adaptive
evolution of primate lysozymes. <i>Nature</i> <b>385</b>:151-154.
</p>

<p>Nei, M., and T. Gojobori. 1986. Simple methods for estimating
the numbers of synonymous and nonsynonymous nucleotide
substitutions. <i>Molecular Biology and Evolution </i><b>3</b>:418-426.</p>

<p>Nielsen, R., and Z. Yang<b>.</b> 1998. Likelihood models for
detecting positively selected amino acid sites and applications
to the HIV-1 envelope gene. <i>Genetics</i> <b>148</b>:929-936.</p>

<p>Rannala, B. and Z. Yang. 1996. Probability distributions of
molecular evolutionary trees: a new method of phylogenetic
inference. <i>Journal of Molecular Evolution</i> <b>43</b>:304-311.</p>

<p>Rodriguez, F., J. F. Oliver, A. Marin, and J. R. Medina. 1990.
The general stochastic model of nucleotide substituions. <i>Journal
of Theoretical Biology</i> <b>142</b>:485-501.</p>

<p>Stewart, C.-B., J. W. Schilling, and A. C. Wilson. 1987.
Adaptive evolution in the stomach lysozymes of foregut
fermenters. <i>Nature</i> <b>330</b>:401-404.</p>

<p>Swofford, D. L. 1993. <i>Phylogenetic Analysis Using Parsimony
(PAUP), Version 3.2</i>. University of Illinois, Champaign.</p>

<p>Swofford, D. L., G. J. Olsen, P. J. Waddel, and D. M. Hillis.
1996. Phylogeny Inference. Pp. 411-501 in D. M. Hillis, C.
Moritz, and B. K. Mable eds. Molecular Systematics, 2nd ed.
Sinauer Associates, Sunderland, Massachusetts.</p>

<p>Tamura, K., and M. Nei. 1993. Estimation of the number of
nucleotide substitutions in the control region of mitochondrial
DNA in humans and chimpanzees. <i>Molecular Biology and Evolution
</i><b>10</b>:512-526.</p>

<p>Tavare, S. 1986. Some probabilistic and statistical problems
on the analysis of DNA sequences. In <i>Lectures in Mathematics
in the Life Sciences</i>, Vol. 17, pp. 57-86.</p>

<p>Thorne, J. L., H. Kishino, and J. Felsenstein. 1991. An
evolutionary model for maximum likelihood alignment of DNA
sequences. <i>Journal of Molecular Evolution </i><b>33</b>:114-124.
(Erratum: <i>Journal of Molecular Evolution </i><b>34:</b>91
[1992].)</p>

<p>Thorne, J. L., H. Kishino, and J. Felsenstein. 1992. Inching
toward reliability: An improved likelihood model of sequence
evolution. <i>Journal of Molecular Evolution </i><b>34</b>:3-16.</p>

<p>Wakeley, J. 1993. Substitution rate variation among sites in
hypervariable region 1 of human mitochondrial DNA. <i>Journal of
Molecular Evolution </i><b>37</b>:613-623.</p>

<p>Wakeley, J. 1996. The excess of transitions among nucleotide
substitutions: new methods of estimating transition bias
underscore its significance. <i>Trends in Ecology and Evolution</i>
<b>11</b>:158-163.</p>

<p>Yang, Z. 1993. Maximum likelihood estimation of phylogeny from
DNA sequences when substitution rates differ over sites. <i>Molecular
Biology and Evolution </i><b>10</b>:1396-1401.</p>

<p>Yang, Z. 1994a. Estimating the pattern of nucleotide
substitution. <i>Journal of Molecular Evolution </i><b>39</b>:105-111<i>.
</i></p>

<p>Yang, Z. 1994b. Statistical properties of the maximum
likelihood method of phylogenetic estimation and comparison with
distance matrix methods. <i>Systematic Biology </i><b>43</b>:329-342.</p>

<p>Yang, Z. 1994c. Maximum likelihood phylogenetic estimation
from DNA sequences with variable rates over sites: approximate
methods. <i>Journal of Molecular Evolution </i><b>39:</b>306-314.</p>

<p>Yang, Z. 1995. A space-time process model for the evolution of
DNA sequences. <i>Genetics </i><b>139</b>:993-1005.</p>

<p>Yang, Z. 1996<i>a</i>. Maximum likelihood models for combined
analyses of multiple sequence data. <i>Journal of Molecular
Evolution </i><b>42</b>:587-596.</p>

<p>Yang, Z. 1996<i>b</i>. Among-site rate variation and its
impact on phylogenetic analyses. <i>Trends in Ecology and
Evolution</i> <b>11</b>:367-372.</p>

<p>Yang, Z. 1998. Likelihood ratio tests for detecting positive
selection and application to primate lysozyme evolution. <i>Molecular
Biology and Evolution</i> <b>15</b>:568-573</p>

<p>Yang, Z. 2000. Adaptive molecular evolution. In <em>Handbook
of Statistical Genetics</em>, D. Balding, M. Bishop, and C.
Cannings, Editors. Wiley: London. In press</p>

<p>Yang, Z., and S. Kumar. 1996. New parsimony-based methods for
estimating the pattern of nucleotide substitution and the
variation of substitution rates among sites and comparison with
likelihood methods. <i>Molecular Biology and Evolution</i> <b>13</b>:650-659.</p>

<p>Yang, Z., and R. Nielsen. 1998. Synonymous and nonsynonymous
rate variation in nuclear genes of mammals. <i>Journal of
Molecular Evolution</i> <b>46</b>:409-418.</p>

<p>Yang, Z., and B. Rannala. 1997. Bayesian phylogenetic
inference using DNA sequences: Markov chain Monte Carlo methods. <i>Molecular
Biology and Evolution</i> <b>14</b>:717-724.</p>

<p>Yang, Z., and D. Roberts. 1995. On the use of nucleic acid
sequences to infer early branchings in the tree of life. <i>Molecular
Biology and Evolution</i> <b>12</b>:451-458.</p>

<p>Yang, Z., and T. Wang. 1995. Mixed model analysis of DNA
sequence evolution. <i>Biometrics</i> <b>51</b>:552-561.</p>

<p>Yang, Z., N. Goldman, and A. E. Friday. 1994. Comparison of
models for nucleotide substitution used in maximum likelihood
phylogenetic estimation. <i>Molecular Biology and Evolution </i><b>11</b>:316-324.</p>

<p>Yang, Z., N. Goldman, and A. E. Friday. 1995. Maximum
likelihood trees from DNA sequences: a peculiar statistical
estimation problem. <i>Systematic Biology</i> <b>44</b>:384-399.</p>

<p>Yang, Z., S. Kumar, and M. Nei. 1995. A new method of
inference of ancestral nucleotide and amino acid sequences. <i>Genetics</i>
<b>141</b>:1641-1650.</p>

<p>Yang, Z. and R. Nielsen. 2000. Estimating synonymous and
nonsynonymous substitution rates under realistic evolutionary
models. <em>Molecular Biology and Evolution</em> <strong>17</strong>,
32-43.</p>

<p>Yang, Z., N. Nielsen, and M. Hasegawa. 1998. Models of amino
acid substitution and applications to mitochondrial protein
evolution. <i>Molecular Biology and Evolution</i> <b>15</b>:1600-1611.</p>

<p>Yang, Z., N. Nielsen, N. Goldman, and A.-M. Pedersen. 2000.
Codon-substitution models for heterogeneous selection pressure at
amino acid sites. <em>Genetics</em> in press.</p>

<p>Zharkikh, A. 1994. Estimation of evolutionary distances
between nucleotide sequences. <i>Journal of Molecular Evolution </i><b>39</b>:315-329.
</p>
</body>
</html>
